# 格课程 11 讲 汇总笔记

*课程页面：https://github.com/coset-io/zkp-academy/tree/main/lattice*

*笔记作者/仓库：MT / https://github.com/mountaintower/learningzkp*

---

## 📑 课程目录

1. [格密码概述](#01-格密码概述)  
2. [什么是格 & 困难问题](#02-什么是格--困难问题)  
3. [离散高斯、拒绝采样、环/模](#03-离散高斯拒绝采样环模)  
4. [NTT 数论变换](#04-ntt-数论变换)  
5. [Ajtai 承诺 & Lyubashevsky 签名](#05-ajtai承诺--lyubashevsky签名)  
6. [构建 SNARKs](#06-构建-snarks)  
7. [实现多项式承诺 PCS](#07-实现多项式承诺-pcs)  
8. [LaBRADOR SNARK](#08-labrador-snark)  
9. [Greyhound PCS](#09-greyhound-pcs)  
10. [Lantern & Lattirust 实现](#10-lantern--lattirust-实现)  
11. [格密码分析初步](#11-格密码分析初步)

---

## 01 格密码概述

### p1 格密码概述

格是后量子零知识区块链的方向

### p2 目录

格密码的五个优势：数学语言通用，有理论计算科学基础，密码分析利器，后量子安全，性能强

### p5 格的3个数学定义，各有所用

1）n维实数域上的离散加法子群；

2）线性无关的基向量B的整数线性组合的集合；

3）整数矩阵的列空间

### p6-10 核心的困难问题

SVP：最短向量问题

SVPγ：找到长度小于γλ1的最短非零格向量（近似），λ1为格上两点最短距离，γ是放松倍数

SIVPγ：找到一组长度小于γλ1~γλn的最短独立向量

CVPγ：找到离指定的t点长度小于γμ的向量，μ是离原点最近的向量长度

CVP变体：离t点的距离最大为d。BDD（有界距离解码）：最多一个解，d小于λ1/2；ADD：至少一个解，d>=μ

LWE：带错学习。As+e=t

### p12

CVP可用于解码：m=CVP(B,t)

### p13

q元格具有周期性，SIS格可以看做满足线性方程组的点集

### p14

LWE可以被看作q-ary格中的CVP。LWE可以看做SIVP的平均版本（LWE的噪声 e 可以被视为SIVP中的“扰动”）。因此，LWE与CVP的近似BDD等价

### p15

MSIS即模SIS（最短整数Solution）问题，对随机A，求满足Az模q为0，且范数小于β的z，z是多项式环Rq上的向量

### p16

SIS格上的SVP

β越大，SIS满足线性方程组概率越高/向量x范围越大，难度越小；β越大，LWE中的s到t的误差e的范围越大，越难恢复出s

### p17

SIS应用：hash算法Ajtai。把m维z向量通过SIS格映射成n维点

### p18

NTRU加解密算法：多项式环上的SVP和CVP问题

密钥生成：h=2g/s，s和g都是短多项式。基于SVP，已知h无法推出短向量s

加密：c=rh+m mod q，r是随机多项式

解密：a=cs=rhs+ms=r2g+ms， m=a mod 2。基于CVP，已知c无法求出最接近的a

### p21

Kyber基于Ring-LWE，公钥加密

Dilithium基于module格上的LWE，签名

FALCON基于NTRU格结构，签名

### p27

从线性代数，概率论，抽象代数开始，连接量子计算、机器学习、计算复杂性、密码学、零知识证明、区块链、信息论、编码理论、伽罗瓦理论、群论、模论、代数数论和代数几何等领域的“大统一”

为代数密码学加入了几何结构，连接离散和连续数学

### p28

向量张成空间，格是n维实数离散子群，理想对标代数数论（取模），模数是在环而不是向量空间的域上的一般化

1）环和域的区别

环（Ring）：环是一个代数结构，它包含一个集合和两个二元运算：加法和乘法。环中的元素可以进行加法、减法和乘法，但不一定有除法。环中的元素不一定有乘法逆元。

域（Field）：域是一个特殊的环，其中的元素可以进行加法、减法、乘法和除法（除零以外）。域中的每个非零元素都有一个乘法逆元。

2）模和向量空间的区别

模（Module）：模是定义在环上的，其标量乘法来自一个环。模中的元素可以进行加法、减法和标量乘法，其中标量来自一个环。

向量空间（Vector Space）：向量空间是定义在域上的，其标量乘法来自一个域。向量空间中的元素可以进行加法、减法和标量乘法，其中标量来自一个域。

3）理想与环的关系

理想是环的子集：理想 I 是环 R 的一个子集，但它不仅仅是任意的子集，而是具有特定的代数性质。

理想在环的运算下封闭：理想在加法和乘法运算下是封闭的，特别是它吸收环中的任何元素的乘法。

理想用于构造商环：理想的一个重要应用是构造商环。给定一个环 R 和一个理想 I，可以定义商环 R/I，它是 R 中所有模 I 的等价类的集合。商环在代数数论和代数几何中非常重要。

### p29

类域理论（Class Field Theory）

类域理论是研究数域 K 的阿贝尔扩张的理论。它提供了数域的阿贝尔扩张与数域的某些代数结构（如理想类群）之间的对应关系。

### p30

数域 K 的基本性质，包括其表示、同构、几何结构和判别式。这些概念在数论中非常重要，特别是在研究数域的算术性质和代数结构时

如果 L 是 K 的代数扩张，那么 L 中的每个元素都是 K 上的代数。换句话说，L 中的元素可以表示为 K 中系数的多项式的根。代数扩张的次数，记作 [L:K]，是指 L 作为 K 上的向量空间的维数。

代数扩张的例子

有理数域的扩张：考虑有理数域 Q 和数域 Q( 更号2），后者是 Q 的代数扩张，因为  

更号2是 Q[x] 中多项式 x^2 −2 的根，而 Q( 更号2) 包含了所有形如 a+b 更号2 的数，其中 a,b∈Q。

### p32

格和复杂性理论，ppp：多项式，鸽笼原理

### p33

最坏情况到平均情况的归约在密码学中是“圣杯”（Holy Grail），意味着破解难度在所有情况下都是一致的

### p34

即使多项式因子的近似SVP也展示了指数级难度

### p35

计算复杂性理论定义的六个世界：多项式世界，启发式世界（P不等于NP，但平均情况下不难），悲观世界（平均情况下难但不存在单向函数可以利用），最小密码世界（有单向函数，没有公钥密码学），密码世界（有公钥密码），混淆世界（不可区分，格）

Witness Encryption（见证加密）是一种密码学原语，它允许将消息加密到某个声明，只有拥有证明该声明为真的“证据”的人才能解密该消息。这种加密方法在密码学中具有独特的应用场景，例如在零知识证明、隐私保护和安全通信中。

Indistinguishability Obfuscation（不可区分混淆）：这是一种密码学原语，它确保即使攻击者拥有无限计算能力，也无法区分两个功能等价的程序。

### p37

iO + minimal hardness：指的是Obfustopia框架依赖于不可区分混淆的零知识证明（Indistinguishability Obfuscation，简称iO）加上最小难度假设。

NP ⊊ iOBPP：表明Obfustopia的难度基础是NP问题，而不是iOBPP问题。iOBPP是一类计算问题，通常认为比NP问题更难

iOBPP（Interactive Oracle Proof of Proximity）是一种交互式证明系统，它涉及一对随机化算法，即证明者（prover）和验证者（verifier），它们共同接收一个码族C中的码C的规范，该码被视为从有限集S到字母表Σ的函数集合。证明者以显式输入的形式接收相同的函数。iOBPP的交互轮数用r表示，查询复杂度用q表示。

iOBPP的定义如下：一个r轮的iOBPP S=(P,V)是一个(r+1)轮的IOP。如果满足以下条件，我们称S是针对纠错码C={f:S→Σ}的r轮iOBPP，其可靠性（soundness）为s:(0,1]→[0,1]，并且与距离度量△相关

### p38

LDN + PRG in NC° + Pairing：这指的是在计算复杂性理论中，线性探测数问题（LDN）和伪随机生成器（PRG）被认为属于NC°类问题。NC°是一类计算问题，这些问题可以在并行计算模型中高效解决。Pairing可能指的是配对（Pairing）问题，它在密码学中用于构造特定类型的密码协议。

Lattice assumptions LWE-with-hints：这指的是基于格的假设和带有提示的学习带误差问题（LWE with hints）。这些假设和问题在密码学中用于构造安全协议，特别是那些旨在抵抗量子计算机攻击的协议。

线性探测数问题（Linear Discriminant Problem，简称 LDN）是密码学中的一个重要概念，它涉及到格理论中的格基向量。在密码学中，格基向量是一组线性无关的向量，它们可以生成整个格。线性探测数问题通常与格的基向量的选择和格的判别式相关联

### p43

LLL算法是密码学和数论中的一个里程碑，它不仅提高了格约简的效率，还影响了密码体系的设计和分析。它的出现使得许多之前被认为安全的密码体系变得不再安全，同时也为基于格的密码体系的构造提供了理论基础。尽管有新的算法如BKZ和Sieving算法等，但它们在复杂度上仍然是指数级的，这表明LLL算法在格约简领域中的基础性地位

### p45

"Truncated LCG"（截断的线性同余生成器）是一种改进的线性同余生成器（Linear Congruential Generator，LCG）的版本，旨在提高其安全性。LCG是一种伪随机数生成器，它基于线性递归关系产生伪随机数序列。然而，如果LCG的参数（乘数a、增量b和模数m）是已知的，那么即使种子值保密，LCG也是可预测的。为了解决这个问题，截断的LCG只输出每个生成数的部分位（例如，只取最低有效位），从而使得预测变得更加困难。

在密码学中，这种截断技术被用来提高LCG的安全性。例如，如果一个密码算法使用LCG生成随机数，并且这些随机数的某些位是公开的，那么截断的LCG可以防止攻击者通过已知的输出位来预测整个序列。尽管如此，研究表明，即使使用了截断技术，LCG仍然可能存在可预测性的问题，因此，它们通常不推荐用于密码学安全应用。

### p48

OWSG（Optimal Witness Size Generator）是一种密码学原语，它与零知识证明（Zero-Knowledge Proofs）相关。在零知识证明中，证明者需要证明他们知道一个特定的值（例如一个密码的私钥），而不需要透露这个值本身。OWSG是一种生成器，它能够生成具有最优大小的证明，使得证明既紧凑又安全。这种生成器在密码学协议设计中非常有用，特别是在需要证明某个陈述的真实性而不泄露任何额外信息的场景中。

### p56

LatticeFold 是一种基于格的折叠协议（folding protocol），由 Dan Boneh 和 Binyi Chen 构建，旨在提供后量子安全性并且可以在小域（例如64位）中操作。LatticeFold+ 是对 LatticeFold 的改进，它在多个方面进行了优化：证明者（prover）更快，验证电路更简单，并且生成的证明更短。LatticeFold+ 通过开发两种新的格技术实现了这些改进。首先，它开发了一种新的纯代数范围证明，这种证明比 LatticeFold 中的效率更高，可能具有独立的兴趣。其次，它展示了如何使用基于和检查（sumcheck-based transformation）的新方法来折叠关于双重承诺（double commitments）的语句。

LatticeFold+ 的主要贡献是提供了一个更高效的格基折叠技术，用于简洁的证明系统。该技术通过使用代数范围证明和双重承诺来缩小证明大小。此外，LatticeFold+ 还展示了如何折叠关于双重承诺的语句，这在构建高效简洁证明系统中非常有用。

LatticeFold 协议利用了基于格的承诺，这可能为后量子安全，并且可以与小域一起工作。然而，LatticeFold 有时需要证明者对所有输入见证提供范围证明，使用比特分解（bit-decomposition），这会减慢证明过程。LatticeFold+ 通过开发新的代数范围证明和双重承诺的折叠技术，解决了这个问题。

LatticeFold+ 协议在效率方面与 Hypernova 相当，同时提供了后量子安全性。LatticeFold 特别适用于使用高阶多项式操作的计算，并且可能成为使用高阶多项式的最高效的折叠系统。LatticeFold 可以作为后量子安全性导致性能提升的一个例子。此外，LatticeFold 可能适用于需要在可验证计算场景中不要求零知识的场合。

总的来说，LatticeFold 和 LatticeFold+ 是构建高效简洁证明系统的重要技术，它们通过利用格基承诺和新的折叠技术，提供了后量子安全性和更短的证明。这些技术对于构建后量子时代的密码系统非常有用

### p57

向量化（Vectorization）

向量化是一种编程技术，它允许单个指令同时操作多个数据点。这种技术通常用于利用现代处理器中的向量处理单元（Vector Processing Units，简称VPU）来提高性能。在密码学和其他计算密集型应用中，向量化可以帮助加速执行重复性的操作，如加密、解密、散列和聚集等。

SIMD操作

SIMD操作是一种并行处理技术，它允许单个CPU指令同时对多个数据执行操作。这种技术广泛应用于现代处理器架构中，以提高对多媒体、科学计算和密码学等应用的处理效率。SIMD指令集通常包括加载、存储、算术和逻辑操作，它们可以同时处理多个数据向量。

### p58

格密码应用未来

信号协议（Signal Protocol）：

PQXDH 是一种基于格的密钥交换协议，它利用 Kyber 公钥加密算法来实现设备间安全通信。这种协议可以在移动设备上实现，如手机和笔记本电脑。

Cloudflare：指的是在云计算环境中广泛部署机器学习密钥封装（Machine Learning Key Encapsulation，简称ML-KEM）技术。ML-KEM 是一种技术，它允许在加密数据上执行机器学习操作而不泄露数据内容。

Algorand：FALCON 是一种基于格的数字签名算法，它被用于状态证明系统（State Proof system）。状态证明系统是一种密码学协议，允许用户在不泄露任何敏感信息的情况下证明他们拥有某些信息或状态。

### p62

ZKP相关：LaBRADOR and Greyhound

1）SLAP框架（SLAP Framework）

Eurocrypt 2024：这是在2024年欧洲密码学会议（Eurocrypt）上提出的一个框架。

首个基于格的多项式承诺：该框架提出了第一个基于格的多项式承诺方案，该方案具有多项式对数证明大小（polylogarithmic proof size）和验证者时间（verifier time）都在标准模块化SIS（Module-SIS）假设下。

具体的证明大小：对于220个约束条件，具体的证明大小为17MB，比之前的基于格的SNARK（Succinct Non-interactive ARgumentation of Knowledge）系统小了15倍。

2）LaBRADOR和Greyhound（LaBRADOR and Greyhound）

Crypto 2023-24：这是在2023-2024年的密码学会议（Crypto）上提出的两个系统。

LaBRADOR：这是第一个基于格的递归摊销R1CS（Recursively Amortized 1-Constraint Satisfaction）证明系统，实现了O(log n)的证明大小（对于2^20个约束条件，证明大小为58KB）。

Greyhound：这是第一个具体有效的基于格的多项式承诺；对于2^30度的多项式，具有53KB的证明大小，并且有一个3轮评估协议。

### p63

LatticeFold 和 LatticeFold+（2024–2025）

LatticeFold：

这是首个针对64位域上的环学习同余（Ring Learning with Errors，简称R1CS）和带错代码学习（Code Learning with Errors，简称CCS）问题的后量子折叠（folding）方案。

该方案的性能与之前的基于配对问题（Pairing-Based Problems，简称PCP）的系统相当。

LatticeFold+：

这是LatticeFold的改进版本，它引入了代数范围证明（algebraic range proofs）和双重承诺技术（double-commitment techniques）。

这些技术使得证明过程快了5倍，并且生成的证明更短。

Neo（Eurocrypt 2025）

Neo：

这是一个基于格的折叠方案，用于CCS问题，它在小素数域上使用“按位付费”（pay-per-bit）的Ajtai承诺。

该方案提供了具体的后量子安全性，意味着它能够抵抗量子计算机的攻击。

这些进展展示了基于格的密码学方案在提供后量子安全性方面的潜力。LatticeFold和LatticeFold+通过改进证明技术和折叠技术，提高了方案的效率和实用性。Neo方案则展示了在小素数域上实现后量子安全性的可能性。这些成果对于设计能够抵御量子计算机攻击的密码系统具有重要意义，因为量子计算机能够破解许多现有的加密算法，包括RSA和ECC。因此，研究和开发后量子密码学方案是密码学领域的一个重要方向

PCP（Pairing-Based Cryptography）是一种基于配对（pairing）问题的密码学方法。这里的“配对”问题指的是在特定的数学结构中找到两个元素的配对，使得它们满足某种特定的数学关系。在密码学中，这些配对问题通常是困难的，即不存在有效的算法能够在多项式时间内解决它们

CCS（Code-based Cryptography Schemes，基于编码的密码学方案）是一种基于编码理论的密码学方法。这类密码学方案利用编码理论中的困难问题来构建公钥密码体系，特别是用于公钥加密和数字签名。
基于编码的密码学方案利用编码理论中的困难问题，如解码问题（Decoding Problem）或最小距离问题（Minimum Distance Problem），来设计密码算法。这些问题在编码理论中是众所周知的难题，它们的计算复杂性为基于编码的密码学方案提供了安全性基础。

前量子时代是pederson承诺

### p64

经典和基于格的多项式承诺

格比FRI还小2倍

### 其它

结构化格（Structured Lattices）是格理论中的一个概念，它指的是那些具有额外结构或规则排列的格。在密码学中，结构化格通常指的是那些可以更容易进行数学操作和分析的格，这些操作和分析对于密码学协议的设计和安全性评估至关重要。

结构化格可以有许多不同的形式，例如：

1. 循环格（Cyclic Lattices）：这些格由单个基向量通过整数倍数生成，并且具有高度对称的结构。

2. 理想格（Ideal Lattices）：在数域上的格可以被视为理想，这些格与代数环的结构紧密相关联。

3. 模块格（Module Lattices）：这些格是更一般的结构，它们允许更复杂的构造，并且可以包含理想格和循环格作为特殊情况。

结构化格在密码学中的应用包括：

- 提高效率：结构化格可以使得某些密码学操作更高效，例如加密、解密和签名生成。

- 安全性分析：通过研究结构化格的性质，可以更好地理解和评估密码学方案的安全性。

- 量子抗性：结构化格理论在设计能够抵抗量子计算机攻击的密码学方案中起着核心作用，因为它们基于的数学问题（如最短独立向量问题）被认为即使在量子计算机上也是难以解决的。

在密码学文献中，结构化格通常与特定的密码学原语和协议相关联，例如基于格的公钥加密（PKE）和数字签名方案。这些方案利用结构化格的数学性质来提供强大的安全保证，同时保持实际应用中的效率和可行性。

NIST实现格算法基本使用C，区块链基本用Rust

其它参考文章

16年的Latiice十年综述

---

## 02 什么是格 & 困难问题

### p1

基本概念。L 和 Λ 都代表格

格的定义：n维实数域上的离散加法子群，只考虑整数格

格的基B。理论分析通常用列变量，工程中经常用行变量表示

### p2

对任何格基B，可定义基本平行六面体P(B) （parallelepiped）。P(B)可以无缝铺满整个格空间 L(B)。

P(B)在三维空间的含义是平行六面体，在二维空间是平行四边形，见kurt老师提供的parallelepiped链接，介绍了线性空间变换（缩放）概念，与B相乘的矩阵A的det(A)即P(B)体积的缩放倍数：
https://www.3blue1brown.com/lessons/determinant

### p3

等价基。基可以变化，但格的形状（格点集）、P(B)的体积保持不变，只要满足B2=B1U（定义4）

其中，U是幺模矩阵（unimodular），即行列式det=±1 的n*n整数矩阵，det可用高斯消元法求解

由于幺模矩阵的det=±1，所以B1U是不会对P(B1)的体积大小有缩放的，B2和B1是等价的

如果Λ=L(B) 是满秩格（n），那么det(A)=|det(B)|，det越小，格点越稠密

### p4

GSO：Gram-Schmidt 正交化将格的基向量B转为正交基

B=QR，Q是正交矩阵，列向量是B的正交基；R是上三角矩阵，是B在Q上的表示

好的基接近正交。无论SVP还是CVP，在正交的基向量之间的相互影响较小，可限制搜索过程。

### p5

定理5 格的最短非零向量长度λ1大于正交化后的最小长度

Minkowski定理：任何体积大于 2^n det(L) 的凸中心对称体 S 包含一个非零格点

λ1上界见推论1.1.7，n个最短向量

Minkowski 定理 2给出了格所有连续最小值的几何平均值的上界

最差情况计算问题：

简单问题：多项式时间

向量是否属于格的成员判定问题：利用高斯消元法

格基等价问题：求解两个线性方程组，检查B1的每个向量在B2中，反之亦然

SVP（λ参数版）

search SVPλ：在格L(B)中寻找最短非零向量v，使得v的长度小于γλ1

optimization SVPλ：在格L(B)中寻找这样的距离d：d<=最短非零向量长度λ1<=γd

promise SVPλ：判定最小非零向量长度λ1不超过实数r或大于γr

### p6

CVP（λ参数版）, 类似SVP

search CVPλ：在格L(B)中寻找离给定向量t距离小于t长度的γ倍的非零向量v

optimization CVPλ：在格L(B)中寻找这样的距离d：d<=给定向量t长度<=γd

promise CVPλ：判定给定向量t长度不超过实数r或大于γr

LLL约简算法：

给定n个线性无关向量b1-n，计算其GSO正交向量；

如果B约简后满足两个要求，可称为δ-LLL约简基（定义2）

如果是δ-LLL约简基，那么b1的长度有上界（与λ1有关）

### p7

LLL属于P算法范畴

GapSVPγ：判定最短非零向量长度λ1<=d 或 λ1>γd

平均情况问题：

q元格定义

Parity Check Lattice指：对矩阵A，满足Ax=0 mod q的x向量集合构成的格（x即A的核空间）

Row-Generated Lattice指：对A和指定的s，满足y=As mod q的m维向量集构成的格

Lemma5：求λ1的上界（Minikowski定理）和下界

### p8

SIS问题

这里definition6 SIS问题定义，A应该是n*m矩阵

对A求SIS等价于在SIS格L(C)上找最短非零向量

这页的PPT的L(C)写出的C矩阵和p7的Parity Check Lattice应该是等价的

不同β表示SIS难度，β越大，难度越低。

对β的分析：A是m*n的矩阵，求Ax=0 mod q 的x，且x的范数小于β

n>m时无法简单解出线性方程组

若β 太小，导致晶格中的向量相对而言太长，x可能无解

若β 太大，可用LLL求解

β处于中间值，可用于密码构造

homework1 why the subgroup generated by (1 + √2) is not a lattice

由于√2是无理数，根据Weyl定理，对于任意小的正数 ϵ，存在整数 m 和 n，使得 ∣m√2−n∣<ϵ。这意味着在 (1 + √2)  Z 中，可以找到两个不同的元素之间的距离可以任意接近，因此不是离散的，也就不是一个格。

homework2 If U unimodular, then U^-1 is also unimodular, and in particular U^-1 ∈ Z nxn

因为det(U)=±1，有det(U^−1 )= 1/det(U)=±1，故U^−1也是幺模矩阵。

U^−1的元素=代数余子式/det(U^−1 )=±代数余子式；因为U是整数矩阵，代数余子式
​
必然是整数

---

## 03 离散高斯、拒绝采样、环/模

### p1

无穷范数

ρ(x)是高斯概率密度即高斯函数

s越大ρ越平坦，s预示曲线宽度

### p2

商群 R^n /L 是R^n关于L的陪集集合，也就是由所有形如 c+L 的陪集构成的集合，其中c∈R^n

就是说，每个陪集都是商群中的一个等价类，可以理解为c+L是对L移位c形成的

L的基本域（fundamental domain）满足每个陪集在基本域中有一个且仅有一个代表。例如，[0,1)和[-1/2,1/2)就是整数格Z的基本域

### p3

GGH96签名举例（不安全）

密钥生成：

bad格基B可以做公钥

good short格基S(s1,s2)可以做私钥陷门用于寻找离t最短的向量x（签名）

签名：

将msg通过H映射为c（在c+L上），使用Babai算法得到c在S基上的最短向量x（仍然在c+L上，因为x=c-e，e是S也是B的线性变换）

Babai最近平面算法是LLL算法（格基约简）中的步骤，用于找到格中离给定向量t最近的向量。核心是让t减去其在每个基向量bi上的投影整数倍得到e，减去的部分加到v（v初始化为0）中，那么可以保持v+e=t不变，同时得到最小的e

这样得到的e肯定是在t的对称多边形Psym(B)范围内的

验签：
使用msg和H求出c，用公钥基B计算c-x是不是属于L（高斯消元法），检查x是不是够小

### p4

GGH96签名的问题：

如果签名次数多，多次得到的e的集合会泄露S形成的P(B)的形状

为了让签名不泄露P(B)，所以希望用高斯分布cover成均匀分布

定义ρs为R^n到R上的高斯函数，fs为周期高斯函数，即格上周期性重复的高斯函数

### p5

s越接近∞，函数越平坦，s越接近0，越接近独立高斯函数

Z上的离散高斯函数举例。整数点离中心越近，值越大，越远，值越小

### p6

对偶格L*可以被理解为原格L的“镜像”或“反转”。

Figure1 原格的基向量 x 和 y 定义了一个平面，而对偶格的基向量则垂直于这个平面，并且它们之间的距离是原格基向量的倒数。

B的转置*对偶格基D=I

平滑参数η，s

直觉理解：需要多少高斯“模糊”来“平滑”格 L 的所有离散结构。换句话说，使得每个c+L 具有几乎相同ρs的最小且大于0的s（宽度）

正式说明：使得对偶格L*上的高斯分布mass ρ≤1+ε 的最小且大于0的s。

这个也可以用下面的公式推导出来

lemma1 均匀分布与采样c+L格归一化后的高斯分布之间统计距离最大为二分之一的对偶格高斯分布。(少加了一个/{0})

定义2：最小的s，使得对偶格高斯分布ρ趋近于0

说明：

对偶格与原格的稀疏程度相反，所以可以用对偶格来控制平滑参数

具体：公式（2）用傅里叶变换、泊松求和公式计算出c+L的高斯密度（与对偶格相关），从而求解s

为了ρ与u无关，控制对偶格在y取0，那么y和u的内积=0，此时在y=0处高斯函数值ρ高，则在非0点的高斯函数值就很小，取这样最小的s就可以得到平滑参数。

定理给出了平滑参数的下界和上界

对偶格L*最短向量λ1越长，需要的s越小，平滑性越好

格基B越长，需要的s越大，平滑性越差

### p7

引理1.36-38的作用：揭示了从高斯分布上的采样大概率是short的，有利于工程实现

### p8

拒绝采样的作用：主要目的是从离散高斯分布D中采样，以生成一个看起来像是从目标分布（如均匀分布）中采样的样本，而不泄露关于私钥或格结构的信息

在给定一个容易采样的分布，根据其概率密度，以一定比例输出/拒绝采样值，来实现想要的目标分布

如：保证sk的S基的安全性，不泄露红色分布，表现出蓝色分布（容易采样）

举例：在蓝色分布上采kq(z0)，要得到红色上的ρ(z)，以1/m概率概率输出z0

但又要保证正确性：确保采样得到的样本 x 与目标点 c 的偏差不会过大

dilithium采用了二项中心分布来替代高斯分布，工程效率角度考虑

lemma 4.2 证明通过适当选择 t(n) 和 s（分布），选择的区间能够覆盖所有需要采样的目标ρs(x)。

这样，采样过程既能够生成符合预期分布的样本，又不会泄露关于格结构的信息

### p9

SampleD算法：确保对n维格的基B，参数s和中心点c，采样得到的点既符合预期的高斯分布，又不会泄露关于格结构的信息。

算法采集的点会比较short，通过先对L正交化，然后把点c在正交向量基上投影生成多个c'i，然后为每个投影采样zi整数系数，接下来与Babai最近平面算法类似，计算满足c+e=v的v

L(B)=Bz，若z是离散高斯分布采用的向量，那么Bz也服从某参数的离散高斯分布

Lemma 4.5 给定一个输入(B,s,c) 和向量 v, SampleD 算法输出特定向量 v 的概率=目标v高斯分布*对不同维度i取Z上的高斯分布（以ci'为中心，si'为尺度）乘积

定理4.1说明SampleD 算法能够在多项式时间内从格上的高斯分布中采样，并且采样得到的样本与目标分布统计上接近

Ring和Modules

### p10

环-SIS ：找到一个非零向量z，使得<a,z>=0，相对于 SIS 的主要优势在于其紧凑性效率

用ring就可以用FFT加速

环-SIS 是 SIS 的一个变体，其中 A 被限制为块负循环矩阵：A=[Rot(a1)∣…∣Rot(am )]，其中 Rot(b) 是一个将向量 b 的系数逆序排列的矩阵

bz=t 等价于Rot(b)z=t，节省了空间，但Rot代数结构的问题，可能会有针对性攻击

### p11

M-SIS: 找到z使得Az=0，也类似R-SIS可以解释为矩阵：d*m，这个矩阵的每一块是Rot(ai,j)，每个Rot(ai,j)是N/d方阵：将向量ai,j的系数逆序排列的矩阵

---

## 04 NTT 数论变换

### 01 NTT数论变换

### 02 不止butterfly

### 03 why & how

### 04 NTTs == FFTs?

FFT是为了计算DFTs

FFT NTT在很多地方指一个东西

### 05 Motivation

提高模多项式乘法，商环多项式乘法的操作效率

### 07

多项式乘法Y=G*H，假设G,H都是d-1度

### 08-10

基本乘法计算和问题：多项式结果的度为2d-2；复杂性：O(n^2)

### 11

y[k]=(g*h)[k]=Σg[i]*h[k-i], i∈[0,k] （离散线性卷积）

当i或k-i超出最终Y的长度（2d-1），相关项就不计算了

解决度为2d-2，无法处理边界的问题

### 14

多项式环: 取模φ(x)

### 15

循环卷积(CC) wraps around

与上面p11的线性卷积不同，取模后有了周期

这里计算c=a*b：

a和b都补齐n次

c[k]分为2项计算，第1项类似p11，第2项是i大于k之后，wrap计算直到i=n

### 16

在Zq[X]/(x^n-1)称为positive，Zq[X]/ (x^n+1) 称为negtive

### 17

PWC/NWC的不同在于计算c[k]的第二项的±不同

解决复杂性：O(n^2)太慢的问题

### 19

卷积（convolution） 理论。一个域中的卷积=另一个域中的点×

所以，把2个多项式系数向量转为NTT，点乘，然后把结果变回多项式即可

### 20

NTT的好属性。 转换NTT后还可可保持随机多项式的randomness，保持dimension和bit长度

### 21-22

NTT iNTT的转换计算

多项式系数向量a的NTT向量：NTT(a)

iNTT向量的计算：乘以n的逆，w^-ij是模q下的w^ij的逆元

w是n维原根 w^n=1 mod q

### 23-24

单位根在复平面上的单位圆上均匀分布，构成了圆周多项式的根，这些圆周多项式(cyclotomic polynomials)是多项式 x^n −1 的一个因式

图中的3个点是1的三个单位根

### 25 例子

2^8 mod 17 =1 , 所以2是8次原根 unity

### 26-28

FFT trick 基于CRT（环版本）简化多项式乘法
定理核心：R：环，Ii：互素的理想，I是理想的交集，那么模I下的元素可以分解为模Ii元素的乘积

例如：R：整数环，I1=2的倍数集合，I2=3的倍数集合，模6整数可分解为模2和模3整数乘积

FFT即使用了类似分解，方根求解到最后，高次递归到线性多项式

### 29

公式10,11即上述CRT正向分解和逆向映射公式

### 30-31

CT butterfly 公式10

### 32

GS butterfly 公式11

### 33

NTT ct no-bo 自然顺序转bit顺序，这里bit顺序(bo)不是0-7是因为输出的顺序是这样

INTT GS  bo-no

### 34

NTT的算法应用

NTT友好：Kyber：Zq [x]/(x^n+1)，Dilithium:Zq [x]/(x^n+1)，Falcon:Zq [x]/(x^n+1)

不友好：Saber，NTRU Prime

---

## 05 Ajtai 承诺 & Lyubashevsky 签名

承诺： 1）SIS，2）Chor-Rivest 哈希，3）Ajtai承诺的binding& hiding

证明： 1）协议，2）安全性：HVZK和知识soundness（relaxed），如果不考虑ZK

### 1 SIS/M-SIS回顾

找到Az=0，z是足够小的m维向量，A是n*m矩阵

### 2 Chor-Rivest Hash

key是n×m的矩阵A，消息是m维比特向量x

Hash函数：fA(x)=Ax mod q

压缩性：因为n<m, 2^m>q^n

抗碰撞性：首先，y=fA(x)=Ax；若找到x'≠ x，且fA(x')=Ax'=y，那么：A(x'-x)=0

若(x'-x)非零，那么可以找到SIS的解(x'-x)，归结到SIS问题

### 3 C-R Hash可以应用到Ajtai承诺构造

单bit版本：

Keygen/Setup： 选择 pk=A∈Z（n×m矩阵）

Commit (u, pk): 承诺1bit u，随机选择(m-1)×1向量r←Dσ，计算com= A * [u,r]^T mod q

Open(u,r,com,pk)：计算得到{0,1}

#### binding性质证明：

首先，com:=commit(u,pk)；然后，要找到u',r', 使得 commit(u', pk)=com

同上抗碰撞证明，可归约到SIS m,n,q,2β 问题

#### hiding性质证明（Pr[u=0]=Pr[u=1] ，即无法从com中区分承诺的是0还是1）：

将矩阵A分解为[a0 | A']，a0是 A 的第一列(n×1)，A′是剩余的 n×(m−1) 子矩阵

那么，com=[a0 | A'] * [u,r]^T=a0 u + A'r

当 u=0 时，com=A′r mod q (可看做A'的SIS格 ={r∈Z^(m-1)| A'r=com mod q})

当 u=1 时，com=a0+A′r mod q (可看做上述SIS格的偏移: a0+L)

第3课讲到的用高斯分布平滑参数s可做到L和c+L采样分布不可区分，因此，u=0和1也无法区分

同理，多bit version的承诺形式如下：

com=A1m+A2r

证明commitment的open正确即不能打开成别的值（binding）

### 4 协议

Shnorr零知识协议: 证明P知道x满足g^x=X，协议满足zk和soundness，协议如下

P                                                                V

选随机数y, 计算g^y=Y (Ay=w)    →    

计算z=y+xc                                  ←    选随机挑战值c

发送z                                            →    使用Y(w)，z，c验证g^z=YX^c (Az=w+tc)

Shnorr可改为Ajtai格版本（见协议的括号部分）：A* [u,r]^T=com =t ∈Rq^n    (即Ax=t)

格版本将Shnorr的计算进行了转换：幂次->乘法，乘法->加法，证明P知道x满足Ax=t

在Ajtai中，y是如何选取的很关键。y←Dσ，故y较小，c是small norm通常也小，x也小（||x||<=2β），故z=y+xc 也小，那么P要伪造z就不容易

### 5 协议安全性

#### knowledge soundness的证明

这里是relaxed版本（relaxed opening），提取的秘密x*可以满足一些要求，但有损失：若P*能得出可被接受的证明 (z, c, w)，那么可以构造一个提取器E，提取出秘密x，使得 Ax=t，且||x||∞<=2β

用rewinding模拟V，提取x*：

P*                V

Ay=w          

                     c
z=y+xc 

倒带：

P*                V

Ay=w              

                    c'

z'=y+xc' 

根据协议有：Az=w+ct，Az'=w+c't（倒带后），这里w是一样的（之后才倒带），t是一样的（承诺t=Ax是一样的）

那么有，A(z-z')=(c-c')t，令x*=(z−z′)/(c−c′) ，有 Ax*=t（V按协议规定行动: 随机选择较小的c，不会多次选一样的c值，不故意破坏E的工作。所以有：(c-c')≠0，(c-c')可逆，设逆元的范数<Bc）
||z||<B，||z-z′||<2B，||x*||∞<Bz，但x*比x大，||x||∞<2β＜Bz

#### HVZK的证明（诚实验证者HV总是按照特定程序抛硬币生成挑战c，故可模拟V的行为自己得到c）

z=y+xc 

y是从高斯分布Dσ采样得到，x是short的，z是y加上xc后的偏移，如果攻击者能观察到多个z，且知道y的分布，那么就能观察到xc的一些信息（泄露x）

为了防止上述问题，采用拒绝采样技术：

拒绝采样：保留偏移和偏移前的重叠部分，拒绝/去掉偏移部分，就不会泄露xc

通过离散高斯分布的拒绝采样：可以保证z看起来像从某个离散高斯分布中采样的

协议的proof是w,z,c，其中，w=Ay与z没有直接关系, y，w都是高斯分布随机采样（在某个范围内均匀），z应用拒绝采样后是平滑分布（统计不可区分）, c是HV的随机数，故x不会泄露

以上即Lyubashevsky 签名方案，x是私钥S，签名是z=y+Sc，验证者验证Az=w+ct，t=AS是公钥

签名者使用拒绝采样技术确保z的分布符合目标分布（不可区分x，ZK），基于秘密S和随机y保证即使观察到多个签名也无法伪造一个新的签名z（不可伪造）

优化拒绝采样策略可减少签名大小，提高其紧凑性

#### 如果不考虑ZK，那么协议可简化，证明是relaxed版

简化协议：P把z=xc发给V，V验证Az=ct即可（z不需要随机的y和c隐藏x）

思路与Greyhound算法类似，Greyhound具有多项式承诺方案的特点，支持透明性、线性证明者、次线性验证者和多对数证明大小

---

## 06 构建 SNARKs

### 1 概述

Geryhound是基于Lattice 的PCS

LaBRADOR 是基于Lattice的SNARKs，所以先介绍SNARKs

### 2 SNARKs：简洁非交互式知识论证

计算完整性的密码学证明，关键是达到short proof和快速验证

所以达不到perfect soundness，但可以computational soundness

1990s起源，是计算复杂性（概率证明）和密码学（高效论证）的交集

### 3 区块链应用：Layer2区块链交易验证

例以太坊需要计算f(x)=v（Layer1），那么区块链做计算需要大量gas，所以现在生成π可以让区块链矿工验证代价比较小

### 4 SNARGs：简洁非交互式论证

SNARK是Knowledge的SNARG，因此是SNARG的特例

ARGuments论证：既要简洁Succinct又要能证明witness，一般不可能，所以需要relax，称为argument

Knowledge知识：可以用rewind extract 秘密，证明w的存在性，比证明拥有w是更强的性质。

P和V的时间size分别是poly(T)和poly(T)/poly(|F|+|x|+logT) （V的验证是快速的）

π的大小是short的：poly（logT）

Setup有不同类型：

公开/透明setup: 如Hash(r),g1,g2=H(g2),g3=H(g2)

隐私setup: universal setup(只与T有关),specific(与F,T都有关，换个F就要换setup了，但效率更高）

### 5 SNARKs的构造范式所基于的（信息论）模型

可以用V的能力区分模型：

oracle access：V可以读其中的几位（P的信息）

randomness：V是随机读的

interaction：P V 多次交互+public coins可以转换为非交互

multi-P：多P之间是隔离的，因此限制了P作恶的能力

### 6 模型

PCP概率验证证明:P发一次，V读几次就结束（不交互很多次）

IP交互证明：交互信息

IOP：P发oracle，V读，交互，多轮PCP的Oracle交互

MIP：V必须读整个msg，而不是oracle

MIOP: 全部考虑

### 7 模型

oracle的种类：

简单版：point 查询

多项式评估查询

tensor查询

线性查询：f和v向量相乘

### 8 模型

MIP：不实用

IP：作为一个子程序用

PCP：不实用

IOP：用的更多，基础

### 9 PCPs

PCP：P只发一个msg，V的验证是随机的（通过oracle查询msg的少量位），没有更多交互

PCP并不是简洁论证，msg的长度还是polyT

为何需要实现oracle：

Prover 可针对 Verifier 的每一次查询即时重新生成不同的msg，使所有局部答案一致，从而欺骗验证V，因此需要把msg绑定成固定不变的字符串，可检测到篡改

可以将消息的每一位做成merkle树的叶子，计算root hash，供V查询

### 10 效率问题

基于PCP的SNARGs的argument size：10s of MBs，并且当T很大的时候（电路规模大）也相当大，如今的进展也很缓慢

但PCP的linear 查询是高效的，如Groth16可以达到O(1)大小的验证

### 11 IOPs

IOP：随机，交互，oracle访问

有了模型（如IOP）（规定理想世界中如何交互、查询，保证可靠性）

再加上密码编译器（PCS，如KZG,FRI,BulletProof等），就可以将模型中的Oracle查询commit、压缩成现实世界里的short的非交互式证明

### 12 构造IOP

16-20年进展很多：拟线性时间ZK，线性大小proof，线性时间P，IOPP线性时间临近证明，高效实现..

新技术：proof组合，单变量sumcheck（但不是我们讲的sumcheck）等

总之，IOP不仅降低了复杂度，在实现上（真实电路规模）的效率也大幅提高

### 13 证明模型的密码学实现

概率证明+密码编译器+代表性SNARK系统

选型关注点

• 计算模型：电路 vs 机器machine

• 密码学成本：Prover 时间、Verifier 时间、证明大小

• 量子抗性：pre / post-quantum

• Setup：公开，特定，通用

linear PCP (and 2-message linear IP)，linear encoding，[G10][L11][BCIOP13]

[GGPR13][PGHR13][G16][GM17]…

PCP and IOP，vector commitment，Ligero, Aurora, Fractal, SCI, STARK, ...

关注点：多项式PCP&IOP，多项式承诺，代表系统：Sonic, Marlin, Plonk, Spartan, Supersonic-RSA, Hyrax, vSQL, vRAM, Libra, ...

### 14 多项式IOP

P发多项式，V发查询多项式值

也支持多变量多项式

### 15 PCS关系

用多项式承诺也可以实现Oracle（就像上面说的Merkle树）

P发多项式承诺F，V对z1点的多项式值做查询，P返回多项式值v和证明π，证明承诺和值计算关系都是合法的

---

## 07 实现多项式承诺 PCS

### 01 为什么讲多项式承诺方案PCS

PIOP+PCS=>SNARKs，能根据需要直接组合出很多方案

VDB也可以用PCS做

补充说明：多项式承诺方案（PCS）的原语，证明承诺的多项式f(X)在z点取值为v=f(z)

Setup($1^λ$, d) → pp
    输入：安全参数 λ，多项式最高阶 d
    输出：公开参数 pp（可能为空，也可能含可信设置）

Commit(pp, f(X)) → (C, aux)
    输入：pp 与多项式 f(X)（deg ≤ d）
    输出：承诺 C（恒定长度），辅助信息 aux（仅 Prover 保留，用于后续open证明）

Open(pp, C, z, v, aux) → π
    输入：pp, 承诺 C, 点 z, 声称值 v=f(z), 辅助 aux
    输出：开证明 π

VerifyEval(pp, C, z, v, π) → {0,1}
    输入：pp, C, z, v, π
    输出：1 表示接受“v = f(z)”；0 表示拒绝在z点的多项式值为v

Batch-Verify：一次验证多点求值

Succinct-Update：更新承诺而不重算整个多项式

一些PCS实例：

KZG：Setup 输出 SRS，Commit 用 SRS 做椭圆曲线运算，Open 生成商多项式证明

IPA-based (Bulletproofs)：Setup 为空，Commit 用 Pedersen-向量承诺，Open 运行对数轮内积协议

### 02 单变量PCS方案1：内积论证IPA

设多项式f(X) 的系数向量为$\vec{f}$，设$\vec{z}$ 为$(z^0,z^1, ...z^{N-1})$，那么多项式值f(z) 就是两个向量做内积的结果

1）Commit：Prover 对$\vec{f}$ 做承诺得到$F=  ⟨\vec{f}, \vec{G}⟩$，公共输入为群元素生成的向量 $\vec{G}=(G_0,..., G_{N-1})$ （在Setup做）

2）Open：公开$F$ ，对公开点$z$ 计算 $v=f(z)$，生成 $v=<\vec{f}, \vec{z}>$ 的多轮（log N）内积论证，输出证明 π。具体过程：

每一轮都对折上一轮的 $\vec{f}$, $\vec{z}$, $\vec{G}$ 为左L右R两部分，然后计算本轮的：$L=<\vec{f_L}, \vec{G_R}>, R=<\vec{f_R}, \vec{G_L}>$，挑战 $c=H(F, z, v, 之前所有轮的L,之前所有轮的R)$

接着进行折叠：$\vec{z'}=\vec{z_L}+c\vec{z_R}，\\\vec{f'}=\vec{f_L}+c\vec{f_R}，\\\vec{G'}=\vec{G_L}+c^{-1}\vec{G_R}，\\F'=<\vec{f'}， \vec{G'}>=<\vec{f_L}+c\vec{f_R},\vec{G_L}+c^{-1}\vec{G_R}>\\=<\vec{f_L},\vec{G_L}>+c^{-1}<\vec{f_L},\vec{G_R}>+c<\vec{f_R},\vec{G_L}>+<\vec{f_R},\vec{G_R}>\\= F+c^{-1}L+cR$

共计算logN轮折叠到1维，得到$π=(L_0,R_0, L_1,R_1, …, L_{logN-1},R_{logN-1}，f_{final})$

3）VerifyEval：Verifier输入F，z，v，π，进行值的验证（无需知道f多项式）

同样计算所有挑战c，通过$F'= F+c^{-1}L+cR$，${z'}={z_L}+c{z_R}$，逐轮进行标量计算折叠得到最终轮的$F_{final}, G_{final}, z_{final}$，验证$F_{final}=f_{final} G_{final}, v=f_{final} z_{final}$

以上是基于Bulletproof的内积论证(inner-product argument，IPA) ，使用Pederson承诺可达到：2log𝑁 证明大小，线性证明(显然下界lower bound是O(N)）和验证时间（O(N)），但这里验证时间并不比证明少

### 03 单变量PCS方案2：商多项式

对公开点z，若有𝑓(𝑧)=𝑣，则： 𝑓(𝑋)−𝑣=𝑞(𝑋)⋅(𝑋−𝑧)，基本协议是：

P发：q(X)

V检查：𝑓(𝑋)−𝑣=𝑞(𝑋)⋅(𝑋−𝑧) 是否成立

但商多项式直接做proof的话，proof太大（比f(X)的度数只小1）

所以可用承诺使得商多项式大小变成O(1)，同时验证等式也要修改：

P发送：商多项式的承诺Com(q(X))

V检查：(Com(𝑓(𝑋))−Com(𝑣))⋅Com(1)=Com(q(X))⋅Com(𝑋−𝑧).

使用采用pairing的KZG做PCS方案如下（KZG把整个商多项式压缩成一个群元素$\pi$，然后用1次配对验证点值）：

1）Setup

可信设置：

$SRS=\{\tau^0 G_1, ..., \tau^{N-1} G_1, \tau^0 G_2, ..., \tau^{N-1} G_2\}$， $\tau$ 是随机的秘密标量，本次协议完成后需要销毁

2）Commit

Prover 计算$\tau$ 点在$G_1$ 上的承诺：

$Com_1(f(\tau))=f(\tau)G_1$

3）Open

Prover计算商多项式q(X)= (f(X) – v)/(X – z)，输出$\tau$ 点在$G_1$ 的证明（即q在$\tau$ 点的值在$G_1$ 上的承诺）：

$\pi=Com_1(q(\tau))=q(\tau)G_1$

4）VerifyEval：Verifier用$\tau$ 点在$G_2$ 做配对验证

Verifier计算：

$v$ 点在$G_1$ 上的承诺：$Com_1(v)=v G_1$

$\tau-z$ 点在$G_2$ 上的承诺：$Com_2(\tau-z)= (\tau-z)G_2$

$G_2$ 其实是1在$G_2$ 上的承诺：$Com_2(1)= 1 G_2= G_2$

检查配对：$e(Com_1(f(\tau))-Com_1(v), Com_2(1))=e(Com_1(q(\tau)),Com_2(\tau-z) )$如果配对验证成功，则有：

$e((f(\tau)-v)G_1, G_2=e(q(\tau)G_1,(\tau-z)G_2)$，即：

$e(G_1,G_2)^{(f(\tau)-v)}=e(G_1,G_2)^{q(\tau)(\tau-z)}$，故有指数相等：

$(f(\tau) – v)=q(\tau)(\tau – z)$，由于$\tau$ 是随机的，故多项式恒等式$q(X)= (f(X) – v)/(X – z)$在全域成立

以上是基于KZG承诺的PCS方案，KZG的proof是 size O(1) （即1个群元素$\pi$），验证时间也是O(1) （1次配对），证明时间是线性的（涉及FFT是拟线性NlogN）

### 04 多变量线性PCS

Multilinear：多变量线性，对每个变量而言其它变量都是常量

有coefficient系数和evalation求值两种形式

系数形式：把多变量项式写成单变量多项式的线性组合，如$f(X_0​,X_1​)=f_{00}​+f_{10​}X_0​+f_{01​}X_1​+f_{11}​X_0​X_1​$

求值形式：把多项式看成超立方体（每个$X_i$ 维只能取0或1）上的拉格朗日插值，如$f(X_0​,X_1​)=f(0,0)⋅(1−X_0​)(1−X_1​)+f(1,0)⋅X_0​(1−X_1​)+⋯+f(1,1)⋅X_0​X_1​$两种形式是为了用于PIOP+PCS的匹配更方便

### 05 多变量线性PCS：IPA

上述两种形式都可以看做IPA $<\vec{f}, \vec{z}>= v$

$\vec{z}$ 就是上述形式中的多变量$X_i$的组合形式

假设多项式系数有$N=2^n$，那么验证时间也是O(N)

我们希望有个小于$2^n$的sublinear算法(√N ）

### 06 多变量线性PCS：IPA举例

$<\vec{f}, \vec{z}>$的内积计算举例（$\vec{z}$ 可以选择第4页提到的任意两种形式之一）

把内积运算中的$\vec{z}$ 拆成了z0z1分量和z2z3分量两个部分，最终得到的内积结果和第4页的多项式是相同的

好处是P V可以分开计算

### 07 多变量线性PCS：IPA举例

P向V发送计算的$[w_0, w_1, w_2, w_3]$， 即z0z1分量部分与f矩阵的乘积

V需要验证其与z2z3分量部分的乘积是否等于v，以及$[w_0, w_1, w_2, w_3]$ 是正确计算出来的（后续发挑战验证）

### 08 多变量线性PCS：IPA举例

V发送挑战$\vec{c}$

P计算f矩阵与挑战的乘积，记为$\vec{t}$

V验证$[w_0, w_1, w_2, w_3]$ 与挑战的乘积$\overset{?}=$ z0z1分量部分与$\vec{t}$的乘积

### 09 多变量线性PCS：IPA举例

设$M=2^m, m=n/2, n= log_2 N$, $M= 2^{({log_2 N}/2)}=2^{{log_2 N^{1/2}}}=2^{log_2 \sqrt N}= \sqrt N$

这样两边的代价都是M

Proof size：P 需要发$\vec{w},\vec{t}$ ，故为 O(M)

使用Bulletproofs-IPA 与 KZG 两种实现可以进一步将多变量求值转化为内积论证IPA，那么proof大小可以到log M和N log N，验证时间是$O(\sqrt N)$ 和O(N)的

### 10 多变量线性PCS-IPA工作

第6页的Bivariant sumcheck：

把 2ᴹ 个系数先排成一个 √N × √N 的矩阵，先对列做一次 sumcheck，再对行做一次 sumcheck，于是：每轮只需处理 √N长度的向量；总复杂度从 O(N) 降到 O(√N)

Bivariant sumcheck+Pederson承诺/RS code/KZG/LaBRADOR=>Hyrax/Brakedown/MERCURY/Greyhound

sumcheck argument（2021）: Sum-check 协议 + 折叠式承诺

basefold（2023）: 多线性多项式+RS码, 使用Σ-check对多线性和式检查+TIPP（2020）双线性群上IPA可实现高效Pairing-based PCS

Hyperwolf （2024）：将Σ-check（basefold思路）转换到格，使用SIS/Module-SIS 假设做承诺（用格上的可折叠承诺（Ajtai/Bonsai-tree 等）替代 RS 码），实现后量子安全的多线性 PCS

### 11 多变量线性PCS-IPA

Sum-check 把“多维”压成“一维”，让 IPA 单变量工具也能给多线性多项式做 PCS。因为基于 Sum-check 的多线性 PCS 协议，把多变量线性多项式（Multilinear）的证明任务，转化成了单变量多项式（Univariate）的打开任务

### 12 多变量线性PCS-商多项式

也可以用类似KZG的商多项式构造

基本协议和基于承诺的改进协议思路见第3页

PST的solution得到的结果是：O(logN)的证明大小和验证时间

---

## 08 LaBRADOR SNARK

### 01 概述

LaBRADOR是基于lattice的SNARKs，声称是第一个和不基于lattice的方案代价相近（即practical）

### 02 术语

$\vec{a} \in \mathbb{Z}_q^m$：m维向量

$\mathbf{a} \in \mathcal{R}_q$：模d阶的多项式环上的多项式，$ct(\mathbf{a})=a_0$，即constant term（多项式的常数项$a_0$）。如果多项式 $\mathbf{a}$ 有d-1阶，那么多项式 $\mathbf{a}$ 可以对应于一个d维向量 $\vec{a}$ （每个分量是多项式的系数）

$\vec{\mathbf{a}} \in \mathcal{R}_q^m$：m维多项式向量

$\sigma(\mathbf{a})$：与 $\mathbf{a}$ 的系数相同，X的幂次取 $\mathbf{a}$ 对应项幂次的负数

内积IP ：向量$\vec{a}, \vec{b}$ 内积和多项式向量$\vec{\mathbf{a}}, \vec{\mathbf{b}}$ 内积的计算是类似的，都是做对应维的多项式分量$a_i$和$b_i$的乘积，再求和

多项式分量$a_i$和$b_i$的乘积计算：对应多项式$a_i$和$b_i$中每一项的乘积，累加求和得到新的多项式

$\langle \vec{a},\vec{b} \rangle=ct(\langle\sigma(\vec{\mathbf{a}}), \vec{\mathbf{b}}\rangle)$

即：先做多项式向量内积Σ$\sigma(a_i)b_i$，然后对每个多项式$\sigma(a_i)$和$b_i$ 的每一项逐个做乘法，然后累加，没有消掉的X的丢弃，消掉X的是常数项，即两个多项式的系数相乘累加

### 03 LaBRADOR 关系 $\mathcal{R}$

Rank-1 Quadratic Constraint Systems（R1CS）是一种用于描述计算问题的约束系统，由一组线性和二次约束组成，这些约束可以表示为矩阵形式的等式：

$A \vec{z} \circ B \vec{z} = C \vec{z}$

其中， $\circ$ 表示向量的哈达玛积（即逐元素乘积）。这个等式表示的是，如果存在一个向量 $\vec{z}$，使得 $A \vec{z}$ 和 $B \vec{z}$ 的逐元素乘积等于$C \vec{z}$，则 R1CS 是可满足的。

实际上，等于$A$的每一行与向量$\vec{z}$ 做内积 $\circ$ $B$的每一行与向量$\vec{z}$ 做内积 = $C$的每一行与向量$\vec{z}$ 做内积

LaBRADOR 关系中的$f(\mathbf{\vec{s_1}},...,\mathbf{\vec{s_r}})=\mathbf{0}$ 计算可以覆盖R1CS 的计算，上述R1CS约束中的向量$\vec{z}$ 包含witness 和instance

f' 用于保证$\mathbf{\vec{s_i}}$ 的范数够小，使用ct 节省了验证开销，只对应256个关系而不是f函数的256*d大小

Bulletproof也是内积arg，通过将（左右边界）向量压缩减少大小，每一轮减少1/2。

lattice无法直接用bulletproof直接做递归的原因：

假设用rewind技巧，把bulletproof的$\vec{s}$ 拆成左L右R两部分，取两次challenge c和c'，那么可得到$\vec{s_R} = (c'-c)^{-1}(\vec{s_c'}-\vec{s_c})$

首先，c'-c 不一定可逆，第二，即使可逆，由于c 的缘故，$\vec{s_R}$ 的范数不一定够小

LaBRADOR 用投影解决了这个问题

### 04 概述

1）承诺：承诺所有$\mathbf{\vec{s_i}}$ 向量，因为上面的关系未必是绑定的

2）投影：重点，证明$\mathbf{\vec{s_i}}$ 向量范数小于$β^2$

3）聚合结果：但cost还是mr

4）摊销：开销变为m

5）验证

### 05 承诺的承诺

第一次承诺：用ajtai承诺r个$\mathbf{\vec{s_i}}$ ，$com=\mathbf{\vec{t_i}}=\mathbf{A\vec{s_i}} \in \mathcal{R_q^K}$，$\mathbf{A}$ 是$k*m$ 的，$\mathbf{\vec{s_i}}$ 是$m*1$ 的，承诺的长度是 r 个 $\mathcal{K}$ 维 $\mathbf{\vec{t_i}}$

再次承诺：将上述承诺$\mathbf{\vec{t_i}}$ 串接起来再次承诺。但这样的 $\mathbf{\vec{t_i}}$ 长度无法保证小，所以可以把$\mathbf{\vec{t_i}}$  二进制分解为多个分向量（只有bit大小），将这些分向量连接起来、再做承诺，这样大小就变小了

### 06 投影：降低范数

根据模JL 引理：如果$||\Pi \vec{s}||_2$ 够小，那么$||\vec{s}||_2$ 也够小，其中，$\Pi$ 是个抽样产生的只包含0（1/2概率)，1（1/4概率)，-1（1/4概率) 的$256*d$ 的矩阵

### 07 投影方法

对每个$\vec{s_i}$，选择一个矩阵 $\Pi_i$ 

根据第2页向量内积计算等于多项式向量内积取常数项的公式：$\langle \vec{a},\vec{b} \rangle=ct(\langle\sigma(\vec{\mathbf{a}}), \vec{\mathbf{b}}\rangle)$，把向量$\vec{\pi}_i^{(j)}$ (即$\Pi_i$ 的第$j$ 行) 和 $\vec{s_i}$ 的向量内积转换为多项式向量内积 $\sigma(\bm{\vec{\pi}_i^{(j)}})$ 和$\mathbf{\vec{s_i}}$（$\Pi$ 是公开的）

首先，保证范数在一定范围内。基于第6页的模JL 引理：

先发送 $\Pi \vec{s} =p $ ，再验证$p<\sqrt{30}b$ ，则$\mathbf{\vec{s}}$ 的范数满足要求

然后，验证$p$ 是正确的。根据上面所说的把向量内积转换为多项式向量内积的公式验证，实际上就是对应于第3页关系中的f'约束

### 08 压缩

压缩F’函数和256个投影函数压缩（随机合成）为1个$\mathbb{Z}_q$ 约束（也可以扩展为$\mathcal{R}_q$约束）

上面的约束+F函数，再压缩成1个$\mathcal{R}_q$约束

### 09 摊销

压缩后只有一个$\mathcal{R}_q$ 约束，形式是第3页的f函数，f函数左边有r个$\mathbf{\vec{s}} ( \vec z )$，故证据proof的大小是mr 个$\mathcal{R}_q$，摊销的目的是把大小减少为m 个$\mathcal{R}_q$

根据下一页的具体推导，验证公式中的每一项展开为：

$f(\mathbf{\vec{s_1}},...,\mathbf{\vec{s_r}})\\ = \Sigma a_{i,j} \langle \mathbf{\vec{s_i}}, \mathbf{\vec{s_j}} \rangle + \Sigma \langle \bm{\vec{\phi_i}}, \mathbf{\vec{s_i}} \rangle - \mathbf{b} \\=   \Sigma a_{i,j} g_{ij} + \Sigma h_{i,i} - \mathbf{b} \\= \mathbf{0}$

注意PPT的公式最右边$\bm{\vec{s_j}}$ 是$\bm{\vec{s_i}}$，只有在$\bm{\phi}$ 和$\bm{s}$ 下标 i=j 的时候，才需要

### 10 摊销方法

对$\mathbf{\vec{s_i}}$ 根据挑战$\mathbf{\vec{c}}$ 进行随机线性组合得到 $\mathbf{\vec z}=\mathbf{c_1} \mathbf{\vec{s_1}} + ... +\mathbf{c_r} \mathbf{\vec{s_r}}$

1）对第5页的ajtai承诺 $\mathbf{\vec{t_i}}=\mathbf{A\vec{s_i}}$，需要在不知道$\mathbf{\vec{s}}$ 的情况下，通过$\mathbf{\vec z}$ 来验证：

两边都乘以 $\mathbf{A}$，得到：$\mathbf{A\vec{z}}=\Sigma\mathbf{c_i\vec{t_i}}$ ，证明这个等式即可

2）对向量$\mathbf{\vec{s_i}}$ 和 $\mathbf{\vec{s_j}}$ 的内积，验证$\mathbf{\vec z}$ 和$\mathbf{\vec z}$ 的内积：

$\langle \mathbf{\vec z},\mathbf{\vec z} \rangle \\=  \langle \mathbf{c_1}\mathbf{\vec{s_1}} + ... +\mathbf{c_r} \mathbf{\vec{s_r}},\mathbf{c_1}\mathbf{\vec{s_1}} + ... + \mathbf{c_r} \mathbf{\vec{s_r}} \rangle \\=  \mathbf{c_1}\mathbf{c_1} \langle \mathbf{\vec{s_1}}, \mathbf{\vec{s_1}} \rangle + \mathbf{c_1}\mathbf{c_2} \langle \mathbf{\vec{s_1}}, \mathbf{\vec{s_2}} \rangle + ... + \mathbf{c_1}\mathbf{c_r} \langle \mathbf{\vec{s_1}}, \mathbf{\vec{s_r}} \rangle \\+ \mathbf{c_2}\mathbf{c_1} \langle \mathbf{\vec{s_2}}, \mathbf{\vec{s_1}} \rangle + \mathbf{c_2}\mathbf{c_2} \langle \mathbf{\vec{s_2}}, \mathbf{\vec{s_2}} \rangle + ... + \mathbf{c_2}\mathbf{c_r} \langle \mathbf{\vec{s_2}}, \mathbf{\vec{s_r}} \rangle \\+  ...\\ + \mathbf{c_r}\mathbf{c_1} \langle \mathbf{\vec{s_r}}, \mathbf{\vec{s_1}} \rangle + \mathbf{c_r}\mathbf{c_2} \langle \mathbf{\vec{s_r}}, \mathbf{\vec{s_2}} \rangle + ... + \mathbf{c_r}\mathbf{c_r} \langle \mathbf{\vec{s_r}}, \mathbf{\vec{s_r}} \rangle $

这里的$\mathbf{\vec{c}}$ 是r*r 矩阵，与m 无关，每个$\mathbf{\vec{s_i}}$ 和 $\mathbf{\vec{s_j}}$内积和$\mathbf{\vec{c}}$ 无关（由于对称，只需要发送一半$\langle \mathbf{\vec{s_i}}, \mathbf{\vec{s_j}} \rangle$ 即可。实际上，可以设$g_{ij} = \langle \mathbf{\vec{s_i}}, \mathbf{\vec{s_j}} \rangle$，发送矩阵G即可

验证$g_{ij}$和$\langle \mathbf{\vec z},\mathbf{\vec z} \rangle$内积是否匹配，从而验证$g_{ij}$ 合法

3）对$\langle \bm{\vec{\phi_i}}, \mathbf{\vec{s_j}} \rangle$，验证：

$\langle \bm{\vec{\phi_i}}, \mathbf{\vec{z}} \rangle \\ =\langle \bm{\vec{\phi_i}}, \mathbf{c_1} \mathbf{\vec{s_1}} + ... +\mathbf{c_r} \mathbf{\vec{s_r}} \rangle \\ = c_1\langle \bm{\vec{\phi_i}}, \mathbf{\vec{s_1}}\rangle + c_2\langle \bm{\vec{\phi_i}}, \mathbf{\vec{s_2}}\rangle + ... + c_r\langle \bm{\vec{\phi_i}}, \mathbf{\vec{s_r}}\rangle$

展开为r项，i再展开、总共发送$r^2$ 项，实际上也只需要发一半，设$h_{ij} = 1/2 (\langle \bm{\vec{\phi_i}}, \mathbf{\vec{s_j}} \rangle + \langle \bm{\vec{\phi_j}}, \mathbf{\vec{s_i}} \rangle)$ ，只有在$\bm{\phi}$ 和$\bm{s}$ 下标 i=j 的时候，才需要

这里的$\bm\phi$ 与后面的$\bm{b}$ 没有关系

现在讨论大小。$g_{ij} = \langle \mathbf{\vec{s_i}}, \mathbf{\vec{s_j}} \rangle$ ，故是短的，但$h_{ij}$ 不一定是短的，因为 $\bm\phi$ 可能是长的，可以再做分解

### 11

递归时，不直接发g，h，需发其承诺（先做分解）

### 12 验证

P发送：$\bm{\vec t,\vec g,\vec h,\vec z}$

V依次验证：

验证承诺：$\mathbf{A\vec{z}}\overset{?}=\Sigma\mathbf{c_i\vec{t_i}}$

验证$\bm{\vec g,\vec h}$正确：$\langle \mathbf{\vec z},\mathbf{\vec z} \rangle \overset{?}=\Sigma\mathbf{c_i c_j g_{ij}}, \Sigma c_i\langle \bm{\vec{\phi}_i}, \bm{\vec{z}} \rangle \overset{?}= \Sigma c_i c_j h_{ij} $

验证压缩后约束f：$f(\mathbf{\vec{s_1}},...,\mathbf{\vec{s_r}})\ = \Sigma a_{i,j} g_{ij} + \Sigma h_{i,i} - \mathbf{b} = \mathbf{0}$

验证$\bm{\vec t,\vec g,\vec h,\vec z}$ 是短的（范数小于β），其大小分别是$r，r^2, r^2, m$ ，若r是很小的常数，那么递归后rm变成m

以上是一步递归验证

### 13 递归

P不发$\bm{\vec t,\vec g,\vec h,\vec z}$ ，将之视为witness，那么又有了一个新的LaBRADOR 关系 $\mathcal{R}$，可以再做一次递归

z做多次递归会爆炸（见第10页），可以做分解解决

LaBRADOR是类似Bulletproof，基于IPA的构造，不是基于PIOP+PCS的形式

LaBRADOR对零知识性质的说明：对亚线性规模的证明系统而言，零知识性质并非关键；当证明长度确实短于见证长度时，非零知识的证明系统反而有有趣的应用场景。此外，只需设计一个简单的线性规模shim协议，即可将输入见证进行掩码，从而轻松实现零知识。该shim可与我们的非零知识证明系统组合，使得组合后的协议仍具备零知识性，且证明长度仅比原系统略有增加。基于上述原因，本文不再关注零知识性质。在与其他证明系统的所有比较中，我们均选用同样不具备零知识性质的版本。

---

## 09 Greyhound PCS

### 1. Greyhound

是基于lattice的PCS，基于laBRADOR 实现PCS。

### 2. 内外双层承诺 (承诺多项式$f(X)$)

假设$f(X)=f_0 X^0 + f_1 X^1 + ... + f_{N-1} X^{N-1}$，将N个多项式系数切分成$r*m$ 矩阵，r*m=N，后面，我们可以将多项式系数矩阵表示成每个m维向量$\vec{f_i}$ 作为列向量的矩阵 。

现在承诺r条m维向量$\vec{f_0}, ..., \vec{f_{r-1}} \in \mathcal{R_q^m}$ ：

1）内层承诺：因为$\vec{f_i}$ 可能很长，不能直接承诺。故将每个$\vec{f_i}$ 分解为短向量$\vec{s_i} \in \mathcal{R_q^{m\delta}}$ (指m维向量$\vec{f_i}$ 中的每一维都拆成$\delta$ 份=>$(f_{i0}, f_{i1}, ..., f_{i (\delta-1)})$，$\delta$ 是分解基)，然后做Ajtai承诺得到$\vec{t_i}=A \vec{s_i} \in \mathcal{R_q^n}$， $A$ 是$n * mδ$ 矩阵。

2）外层承诺：将每个n维向量 $\vec{t_i}$ 分解为短向量$\vec{t'_i} \in \mathcal{R_q^{n\delta}}$，然后将r个$\vec{t'_i}$ 串联起来($\in \mathcal{R_q^{r n \delta}}$)，再次做Ajtai承诺得到$\vec{u}=B (\vec{t'_1}, ..., \vec{t'_n}) \in \mathcal{R_q^n}$， $B$ 是$n * rnδ$ 矩阵。

等于将多项式系数表示成了短向量$\vec{u}$。

分解的时候可以选择2进制，这样分解的结果只有0或1，向量小，容易处理。

### 3. 二次型关系（两个线性映射的乘积，如$a F b=y$ ,参见第7课第6页）

上面的双层承诺已经把多项式系数压缩成一个短承诺 $\vec{u}$ ，现在证明：对于公开点x，二次型关系成立，并且不会泄露witness。

witness：$(\vec{s_i}, \vec{t_i})_{i \in [r]}$。

公开输入：$\vec{u}，\vec{a}，\vec{b}$，整数 $y$。

关系：

验证矩阵：$y=f(x)$ 求值；

验证$\vec{f_i}$正确分解成$\vec{s_i}$：$\vec{f_i}=G_m \vec{s_i}$；

验证$\vec{t_i}$ 是$\vec{s_i}$ 的承诺；

验证$\vec{t_i}$生成$u$：先分解成$\vec{t'_i}$，然后生成最终承诺。

### 4. 简单版协议：证明上述关系

类似brakedown的方法：

1）P发左乘向量$\vec{w}$；

2）V发短向量挑战$\vec{c}$；

3）P发分解向量$\vec{t'_i}$，计算$\vec{z}$（即$\vec{c}$ 和$\vec{s}$ 的随机线性组合，$\vec{s}$ 与$\vec{f}$ 只差一个$G_m$，验证$\vec{c}$ 和$\vec{f}$ 的组合也是一样的）

### 5.简单版协议

4）V验证：

y的计算正确，即第一行验证的前半部分；

$\vec{w}$ 的计算正确，即第一行验证的后半部分：挑战随机线性组合关系的计算正确（左边等于$\vec{a} \vec{f} \vec{c}$，右边等于$\vec{a} G_m \vec{s} \vec{c}= \vec{a} \vec{f} \vec{c}$）；

验证ajtai承诺正确，即第二行验证的前两个部分：先用分解向量$\vec{t'_i}$ 组合成inner承诺$\vec{t_i}$，然后验证$\vec{t_i}$ 与挑战$\vec{c}$ 组合是否等于线性组合$\vec{z}$ 的承诺；

验证outer 承诺，即第二行验证的最后一个部分：用inner承诺$\vec{t_i}$ 的承诺验证；

最后验证$\vec{t'_i}, \vec{z}$ 是短的。

### 6. 减少证据大小：使用LaBRADOR关系

P发送的大小取决于： $\vec{w} \in \mathcal{R_q^r}，\vec{t'_i} \in \mathcal{R_q^{n \delta}}$（虽然大，与r和m无关），$\vec{z} \in \mathcal{R_q^m}$。

使用LaBRADOR关系描述第5页的验证关系，从而将代价减少到 $r=m=\sqrt N$。

### 7. 减少证据大小：使用LaBRADOR关系

首先，第4页协议第1步：P不发送$\vec{w}$，而是发送$\vec{w}$分解后的$\vec{w'}$的承诺$\vec{v}$ ，以及第3步发送 $\vec{w'}$；

然后，第5页验证：要增加验证承诺$\vec{v} \overset{?}= Com(\vec{w'})$。

单纯地看，Proof大小还增加了分解后的$\vec{w'}$，但这里的问题是如何调用LaBRADOR。

使用本页的矩阵乘法：

第1行：验证承诺$\vec{v}$;

第2行：验证第5页outer 承诺$\vec{u}$；

第3行：验证第5页$\vec{w}$ 和$\vec{b}$ 左乘等于求值y （第5页第1行左边验证）；

第4行：验证第5页$\vec{w}$ 和$\vec{c}$ 随机线性组合等于$\vec{w}, G_m$  和$\vec{z}$ 线性组合（第5页第1行右边验证），即验证$\vec{w}$ 是正确的；

第5行：验证第5页$\vec{t_i}$ 的分解和ajtai承诺(见第3页对$\vec{s_i}$ 的承诺$\vec{t_i}$ )；

最后验证3个向量是短的。

若将矩阵公式精简成$E \vec{d}= \vec{f}$ ，那么 $\vec{d}$ 是witness，其它都是公开输入。这个关系完全可以用第6页LaBRADOR的公式第2项（$\Sigma<\Phi_i,s_j>$）检查。

所以Greyhound 等于把N维向量变为$\sqrt N$ 大小的向量，然后在上面实施LaBRADOR-IPA得到$O(log\sqrt N)=O(logN)$ 的Proof大小，验证时间是$O(\sqrt N)$ 的。

### 8. 多项式承诺

最终要证明的是普通整数域$ {ℤ_q} $上的多项式$f(X)$求值（多项式的系数$f_i$ 是标量），而Greyhound的双层承诺是在环 $R_q = ℤ_q[X]/(X^m + 1)$ 定义的（多项式$f(X)$的r 个原始系数$\vec{f_i}$ 都是m维向量，见第2页第1行，所以需要被拉平成mr个${ℤ_q}$标量计算）。

即把在$R_q$ 上的$f(X)$ 求值证明扩展到${ℤ_q}$上：$f(x) = Σ_{i=0}^{mr-1} f_i x^i = y\ mod\ q$。

Greyhound 方案：

1）把r 个环元素系数$\vec{f_i}$ 展开成 m·r个$ℤ_q$标量（即把环里的每个多项式系数 $\vec{f_i}$ 拆成 m个整数系数），系数$\vec{f_i} $ 的展开见PPT，按 m×r 矩阵展开）：$f(x)= [1,x,x^2,…,x^{m-1}][\vec{f_0},\vec{f_1},...\vec{f_{r-1}}][1,x^m,x^{2m},…,x^{(r-1)m}]^T$。

这里的$f(x) $分解的3项中的第1个（长度为m）和第3个（长度为r）与x相关的向量，相当于第3页的向量a和b，做外积展平： $a ⊗ b=（1，x^1, ... x^{mr-1})$。所以全部乘起来就是$f(x)$的取值，这样可以压缩协议传输的通信量。

2）用$ℤ_q$上的内积完成最终的Σ-check 求值检查：

已知 $f(x)=⟨ (f_0,…,f_{mr-1}), (1,x,x²,…,x^{mr-1}) ⟩ $， 实际上是对公开点z，求解$<\vec{f},\vec{z}>=\Sigma_{i \in [0,mr-1]} f_i z_i$。 采用LaBRADOR的$ct(<\sigma(\vec{a})，\vec{a})>$技巧(见LaBRADOR讲课PPT第2页)，就能将上述向量内积转换为$ct(<\sigma(\vec{f})，\vec{z})>$ （交叉项都被丢弃了）。

然后用LaBRADOR-IPA就可以一次性递归证明内积了，代价是O(logN) 。

### 9. HyperWolf：从单变量->多变量线性

目标：把 Greyhound 的二次型关系证明从二维矩阵压缩推广到 k 维超立方体，进一步降低通信与验证复杂度。

核心思想：

1）将长向量 f（长度 N）视为 k 维超立方体网格（每维大小 N^{1/k}）。

2）用 k 维分段幂向量 代替 Greyhound 的二维 a、b 向量：通信/验证复杂度降至 $O(k N^{1/k})$。

3）取 k = log N 时，复杂度变为 O(log N)，无需再跑 LaBRADOR，协议自身即递归 Σ-check。

### 10 -11. HyperWolf举例（假设有8个$f_i$系数，立方体）

证明这里的$f(x)$取值（3个变量$x_i$），将x向量拆成$x_1, x_2$和$x_3$两部分

所以reduce成的第9页最后一行图的关系（蓝色部分乘积公开g_i，绿色部分乘积公开y_g）等同第10页最后一行

### 12. HyperWolf举例

这里实际上是Greyhound了，V最后验证的等式类似第5页Grey第一行后半部分验证。

### 答疑

关于knowledge soundness：greyhound PCS 调用了LaBRADOR的knowledge soundness

仍然使用rewind技术，得到：(c1-c2) (f1-f2) =A，需要考虑c‘ 可逆，向量是短的等等，与LaBRADOR的投影有关（是relaxed的）。见Greyhound的lemma 3.2：CWSS：Commit-With-Small-Solution，保证协议“要么提取有效见证，要么破坏格假设”。

---

## 10 Lantern & Lattirust 实现

### 参考文献

Lattice-Based Zero-Knowledge Proofs Implementing Lantern 
https://lattice-zk.isec.tugraz.at/  

Greyhound PCS PoC https://wiki.lacom.io/wiki/cryptography/greyhound-poc

https://github.com/lattirust/lattirust

https://github.com/NethermindEth/latticefold

https://hackmd.io/@Ingonyama/fast-labrador-prover
中文版：https://mp.weixin.qq.com/s/EDNjRUT5colRRROm6WhCWA

### Lattice-Based Zero-Knowledge Proofs Implementing Lantern

#### 目录

1. [介绍](https://lattice-zk.isec.tugraz.at/#1.-Introduction)
   
   1.1 [零知识证明](https://lattice-zk.isec.tugraz.at/#1.1-Zero-Knowledge-Proofs)
   
   1.2 [格密码](https://lattice-zk.isec.tugraz.at/#1.2-Lattice-Cryptography)

2. [相关工作](https://lattice-zk.isec.tugraz.at/#2.-Related-Work)

3. [Lantern 零知识证明方法](https://lattice-zk.isec.tugraz.at/#3.-Lantern-Zero-Knowledge-Proof-Approach)
   
   3.1 [承诺方案](https://lattice-zk.isec.tugraz.at/#3.1-Commitment-Scheme)
   
   3.2 [线性关系](https://lattice-zk.isec.tugraz.at/#3.2-Linear-Relations)
   
   3.3 [二次关系](https://lattice-zk.isec.tugraz.at/#3.3-Quadratic-Relations)

4. [实现](https://lattice-zk.isec.tugraz.at/#4.-Implementation)
   
   4.1 [预备知识](https://lattice-zk.isec.tugraz.at/#4.1-Preliminaries)
   
   4.1.1 [多项式环 Polynomial ring](https://lattice-zk.isec.tugraz.at/#4.1.1-Polynomial-Rings)
   
   4.1.2 [随机分布和抽样](https://lattice-zk.isec.tugraz.at/#4.1.2-Random-Distributions-and-Sampling)
   
   4.1.3 [拒绝抽样](https://lattice-zk.isec.tugraz.at/#4.1.3-Rejection-Sampling)
   
   4.1.4 [挑战空间](https://lattice-zk.isec.tugraz.at/#4.1.4-Challenge-Space)
   
   4.2 [ABDLOP 承诺Opening证明——在$\mathcal{R_q}$ 上的线性证明](https://lattice-zk.isec.tugraz.at/#4.2-ABDLOP-Commitment-Opening-Proof-with-Linear-Proofs-over-Rq)
   
   4.3 [$\mathbb{Z_q}$上的线性证明](https://lattice-zk.isec.tugraz.at/#4.3-Linear-Proofs-over-Zq)
   
   4.4 [$\mathcal{R_q} $上的二次证明](https://lattice-zk.isec.tugraz.at/#4.4-Quadratic-Proofs-over-Rq)
   
   4.5 [$\mathbb{Z_q}$ 上的二次证明](https://lattice-zk.isec.tugraz.at/#4.5-Quadratic-Proofs-over-Zq)
   
   4.6 [模-LWE 秘密的知识证明](https://lattice-zk.isec.tugraz.at/#4.6-Proving-Knowledge-of-a-Module-LWE-Secret)
   
   4.7 [用于证明格关系的工具箱](https://lattice-zk.isec.tugraz.at/#4.7-Toolbox-for-Proving-Lattice-Relations)
   
   4.8 [基准代码](https://lattice-zk.isec.tugraz.at/#4.7-Benchmark-Code)

5. [基准测试](https://lattice-zk.isec.tugraz.at/#5.-Benchmarks)

6. [结论](https://lattice-zk.isec.tugraz.at/#Conclusion)

#### 1 介绍

2022年提出的Lantern（LNP）是高效的对MLWE秘密（及其它格statement）的知识证明算法，比19年基于Hash的Aurora（实际效率基本不可用），证明格statement的效率高。

但该算法的Proof大小，验证时间没有那么好，不是简洁的，是交互式的。

##### 1.1 ZKP

ZKP三个性质：正确性，可靠性，零知识性。

为了达到ZKP先要理解承诺方案：分为两步。一方承诺一个选定值（作为秘密），稍后打开/open这个值；其它方可验证这个值与承诺是对应的。有两个性质：隐藏和绑定。

承诺原语一般基于DL。直接给DL承诺，如$g^s$，验证会泄露s。Schnorr协议通过增加对y的承诺$g^y$，公开$z\leftarrow y+ cs$，可以让P证明知识s（验证：$g^z \overset {?}= w t^c$），但不会泄露s给V。

但在格里要求范数小的问题会对协议造成困难，原本y只需要在Zq均匀抽样，但这样y就太大导致z太大，而且y的取值还要不能泄露s（格的多边形分布）。那么就需要比较小y，因此y是从高斯分布采样且不是随机的。由于y不是随机的，z需要拒绝采样、防止泄露s的信息。另外，格中的c也要小，要在特定挑战空间中采样。

##### 1.2 格密码

Lantern协议建立在多项式环上的MLWE和MSIS问题上。

MSIS可以用来做承诺：$\bold{t=As}$；打开：$\bold {s}$，要求||$\bold {s}$||小

09年Lyubashevsky提出基于格的Schnorr证明，与上面的Schnorr类似，验证：$||\bold{z}|| \overset {?} \leq B, \bold{w \overset {?} = Az} -c\bold{t}$

证明了知道一个$\bold {\overline s} \in \mathcal{R_q}$ ，使得$\bold{A\overline s}=c\bold{t}$，且其范数大于||$\bold {s}$||。

这里的P计算$\bold{z}$时，需要拒绝采样。具体原因1.1已说明。

以上协议已经可以做签名了，比如Dilithium（ML-DSA）就是其非交互式版本。但是上面说的提取的$\bold {\overline s}$范数大于$\bold{s}$ （实际上是个relaxed版本）通常会导致效率或功能问题。比如基于Regev风格的格加密方案：$\bold{A\overline s}=c\bold{t}$，$\bold{s}$（包括明文消息）是随机的，$\bold{t}$是密文。解密时，$\bold{t}$必须有短的原像。但模约简的proof不能保证$\bold{s}$是短的，只能保证$c\bold{t}$有短的原像（解密算法不知道c）。

而Lantern就不用放松了，是精确的证明。

#### 2 相关工作

Lantern的证明大小最小：13KB，接近最低的8KB。

#### 3 Lantern 零知识证明方法

关键在于证明$\bold{s}$的范数是小的，即$\mathbb{Z}$上的二次关系：$<\bold{s},\bold{s}><=B^2, B \in \mathbb{Z}$。

先用承诺方案在$\mathcal{R_q}$上证明线性关系，然后在$\mathbb{Z_q}$上，最后在$\mathbb{Z}$上。

然后用承诺方案证明$\mathcal{R_q}$上的二次关系，然后是$\mathbb{Z_q}$上，最后为了在$\mathbb{Z}$上证明二次关系，混合了$\mathbb{Z}$上的线性关系和$\mathbb{Z_q}$上的二次性关系。

##### 3.1 承诺方案

结合Ajtai（$\bold{A_1s_1+A_2s_2=t}$）和BDLOP，提出ABDLOP承诺。

$\bold{s_1}$是秘密，$\bold{s_2}$是随机数。

##### 3.2 线性关系

$\mathcal{R_q}$上的线性关系(用Ajtai举例说明)：

除了对Ajtai承诺（$\bold{A_1s_1+A_2s_2=t}$）中的$\bold{s_1} \in \mathcal{R_q}$证明线性关系，再加一个：$\bold{-Rs_1+0 s_2=r}$ 即 $\bold{Rs_1+r =0}$，证明了$\mathcal{R_q}$上的给定线性关系。

$\mathbb{Z_q}$上的线性关系：

接下来可以用代数等式提升证明，得到$\mathbb{Z_q}$上的线性关系。

两个多项式系数向量（$\bold{a,b} \in \mathcal{R_q}$）内积（$\mathbb{Z_q}$上的线性关系）$\langle \mathbf{a},\mathbf{b} \rangle$可以用之前讲的多项式乘积（$\mathcal{R_q}$上的线性关系）$ct(\langle\sigma({\mathbf{a}}), \mathbf{b}\rangle)$计算。这里采用的是环自同构结构，与之前讲的$\sigma$不太一样，但结果相同。

$\mathbb{Z}$上的线性关系：

这里用到第8次课 LaBRADOR第6页的JL引理：如果$||\Pi \vec{s}||_2$ 够小，那么$||\vec{s}||_2$ 也够小，其中，$\Pi $是个抽样产生的只包含0（1/2概率)，1（1/4概率)，-1（1/4概率) 的矩阵。

Lantern的定理：如果$||\bold{z=y+Cs}\ mod\ q||_2$ 够小，那么$||\bold{z}||_2$ 也够小。但这只是近似的短证明，$\bold{z}$并不是和$\bold{s}$完全一样大，因为有$\bold{y}$和$\bold{C}$，但现在可以近似验证没有大于模q的情况发生。

##### 3.2 二次关系

每个协议都会实现自己的二次关系。

#### 4 实现

注意4.1.2 使用的随机函数random并不安全，实践中应该替换。

### Greyhound PCS PoC

1 Gadget矩阵构造

1.1 什么是Gadget矩阵

1.2 数学定义

1.3 二进制分解（Gadget Inverse）

1.3.1 算法

1.3.2 为什么用二进制分解

2 LaBRADOR承诺方案

2.1 概述

2.2 数学架构

2.2.1 内承诺

2.2.2 外承诺

2.3 承诺打开

2.3.1 打开组件

2.3.2 验证条件

3 证明二次关系

3.1 概述

3.2 协议结构

3.3 验证条件

3.4 Prover实现

3.5 Verifier实现

4 减少证明大小

4.1 证据太大的问题

4.2 解决办法：承诺w

4.3 修改协议

4.4 额外验证

4.5 实现：优化协议

5 多项式求值证明

5.1 从二次关系到多项式求值

5.2 提高批效率构建

5.3 二次关系

5.4 协议流

5.5 优点

5.6 实现：多项式求值

5.7 多变量多项式框架

5.7.1 向量-矩阵-向量 表示

5.8 FS变换

6 结论和应用

6.1 成果总结

6.2 Greyhound PCS的关键优点

参考文献：2篇

### 其它

今天讲的都是Python，区块链用Rust很多。

LaBRADOR和Greyhound原文都有C实现，但细节过多，不建议。

lattirust实现了LaBRADOR：[https://github.com/lattirust/lattirust]()

借鉴上面的代码，实现了latticefold：[https://github.com/NethermindEth/latticefold]()

比较快的实现了LaBRADOR，可以直接看末尾的rust：[https://hackmd.io/@Ingonyama/fast-labrador-prover]()

---

## 11 格密码分析初步

### 参考文献

- First Step to Lattice-based Cryptanalysis in SageMath. https://wiki.lacom.io/wiki/cryptanysis/cryptanysis-sage-101/#babais-nearest-plane-algorithm
- [A Gentle Tutorial for Lattice-Based Cryptanalysis](https://eprint.iacr.org/2023/032)
- [Linear algebra and lattice reduction in Sage](https://defeo.lu/sage-lattices-EJCIM/)
- [Cryptanalysis on Lattice-Based Cryptography](https://hackmd.io/@Giapppp/BJ4wfpZST)
- [Using Lattices for Cryptanalysis](https://simons.berkeley.edu/sites/default/files/docs/14975/cryptanalysis.pdf)
- [Solving Hidden Number Problem with One Bit Oracle and Advice](https://www.iacr.org/archive/crypto2009/56770333/56770333.pdf)
- [Sage for Lattice-based Cryptography](https://www.maths.ox.ac.uk/system/files/attachments/sage-introduction.pdf)
- https://www.latticechallenge.org/
- https://lattice-estimator.readthedocs.io/en/latest/
- [The GGH Cryptosystem](https://kel.bz/post/lattices/)
- [Building Lattice Reduction (LLL) Intuition](https://kel.bz/post/lll/): 17年，经典
- [LLL algorithm](https://www.youtube.com/watch?v=vREqxm0j784)
- COMPLEXITY OF LATTICE PROBLEMS: A Cryptographic Perspective Ch2， 2004
- Mathematics of Public Key Cryptography. Version 2.0 by Steven D Galbraith，2008

### 基于格的密码分析初步（SageMath）

![image.png](https://wiki.lacom.io/build/8a8dfd61ad2a349806018b185f6003de.png)

基于格的通用攻击方法：密码构造转换为基于格的问题，通过格构造转换为格问题，通过格约简得到解决方案。

![image.png](https://wiki.lacom.io/build/c8fa3f612fc42250335ec1cb92c21ed4.png)

举例：RSA/ECDSA/Truncated LCG的密码构造，首先转化为：找到最小根问题/隐藏数问题，然后转换为SVP或CVP问题，最后通过格约简得到秘密（如密钥）。

说明：在工程中一般使用行向量表示格中的矩阵。

BKZ是基于LLL的增强算法，通过引入（block reduction）和枚举（SVP oracle）机制（设定一个“分块大小β”，对每个β维的子格进行更精细的优化，从而得到更短的基向量），在牺牲部分效率（运行时间更长，尤其在β较大时）的前提下显著提升了格基约化的质量。

#### 基于格的攻击举例：基于secp256k1（256位素数域p上的高效Koblitz曲线k1标准）的椭圆曲线签名算法攻击

##### ECDSA签名算法

n是椭圆曲线的阶。
私钥：d∈[1,n−1]
消息哈希：Z=H(m) mod n
随机选 nonce：k∈[1,n−1]
计算曲线点：(x1 ,y1)=k⋅G
取横坐标：R=x1 mod n
计算逆元：k^(−1) mod n
计算签名：S=k^(−1) (z+Rd) mod n
签名=(R,S)

##### 1）当nonce ki=zi ⊕d时（消息的哈希z与私钥d的异或），基于至少2个消息及其签名，分析出ECDSA签名私钥

方法：ECC-->knapsack 背包问题-->subset_sum问题-->lattice 问题SVP，用LLL/BZK求解。

核心：

当k等于z和d的异或时，可以展开为：k等于z和d的加法，然后减去每个j bit的进位。那么ecc签名公式（上面公式：S=k^(−1) (z+rd) mod n）可以带进去展开，里面只剩下d是未知数。

可以简化为Σaij dj =bi，这里a和b都可以有效计算，那么这就变成了subset sum问题（SSP，背包问题）：dj表示第j位选（1）还是不选（1）。即：给定一组数，找到其子集，使得子集数的和为给定目标，要求输出选或不选集合元素的向量。如果要选多个子集：就是MMSSP问题（多重）。

接下来，把SSP转换为格问题SVP：把“背包求和”改写成“找一组 0/1 系数，使向量线性组合落在目标点附近”，于是 0/1 背包解就变成了格里的短向量。

MMSSP根据上面的i=ℓ个简化方程式Σaij dj =bi，求和后简化。为了方便，可以表达为d^T A =b'，根据系数矩阵A和目标向量b'，求密钥d向量。其中，d^T是1×m，A是m×ℓ，b'是1×ℓ的。然后构造升维格基，把MMSSP转成格 SVP，让 0/1 解恰好成为格里最短的向量。

###### 1.1）简单格构造，取大整数N> √m  (经验值 N ≈ 2^{m/2})，构造 (m+1)×(m+1)的格基矩阵 B

先把 ℓ 条方程Σdj aij =bi加上随机数向量r（随机系数 r_1,…,r_ℓ 需足够大且独立），线性组合压缩成 1 条方程，设为d a'' =b'', 其中，a''=Σ r_i a_i（ a_i 是 m×1 向量）, b''=Σ r_i b_i（ b_i ∈Z）。

B = [ I_{m×m}     a''_{m×1}]  
       [ 0_{1×m}     b'']

设线性组合 t = (d, -1)，设t·B=x1，那么有 t·B = (d, 0)=x1。把这个矩阵等式tB=x1按照t中的每个元素拆开就等于：d=d，da''-b''=0，就是上面的压缩方程组d a'' =b''。也就是说构造的B使得tB=x1，等价于之前的MMSSP方程组。

可以看到B是  (m+1)×(m+1)的格基矩阵，可以理解为B 的列向量生成了一个 (m+1) 维的格，由于x1= (d, 0)= (d_1,…,d_m, 0)，故||x1||_2=√（Σ d_j² + 0²），1≤ ||x1||_2≤√ m，其二范数显然最大是√m，最小是1。

tB得到的x1仍然是格L(B)上的格点且极小（ ||x1||_2≤√ m），那么上述问题就转化为找到格中的最短非零向量的SVP问题：求格L(B)中的最短向量x1=(d, 0)，所以可以用LLL 把这个格点对应的向量x1求出来，前 m 位就是 d。

###### 1.2）CJLOSS格，构造(ℓ+m)×(m+1) 的格基矩阵 B

B = [ I_{m×m}     Na'' _{m×1}]  
       [ (1/2)_{1×m}     Nb'']

线性组合 t = (d, -1)，乘后得 x2=t·B = (d_1-1/2,…,d_m-1/2, 0), ||x2||_2=1/2√m，同样可求格中唯一最短向量。

###### 1.3）PZ16格，取大整数N> √(（m+1）/ 4 )，构造(k+m+1)×(m+k+1)的格基矩阵 B（文章中的n是这里的m）

右上 m×k 矩阵（除了单位矩阵和全0列的部分）：把每条方程的系数放大 N 倍。

中间 m×k 矩阵：对应密钥 d_1 … d_m。

最后 1 行的后k个元素：对应目标签名S=（s_1... s_k）。

这里线性组合  t = (d_1,…,d_m, -ℓ_1,…,-ℓ_k, -1)，乘上矩阵 B 后得到  x3 =tB= (k_1-1/2,...k_m-1/2,-1/2,-1/2, 0,…,0) ，这里的等式Σdj aij =bi变为：Σdj aij =bi+ℓ_iM。

矩阵是m+k+1行，这就是前面代码“[subset_sum] Lattice dimensions: (107, 107)”中格基B的维度参数（107）。

假如有ℓ个签名就有ℓ个简化式，假设密度ρ=未知的密钥比特位数/所有方程的信息量=m/(ℓ log_2 n)≈m/(ℓ m)=1/ℓ。那么2条签名意味着ρ=0.5，当ρ≤0.5时，这就是一个低密度问题，可以用LLL/BKZ在多项式时间内找到唯一解，当ρ接近1时解空间会爆炸。

##### 2）针对更不安全的nonce的攻击：假如nonce k是重复使用的，直接2条签名S相减，一个方程就可以计算出d

##### 3）针对biased nonce（如k的一些连续高位=0）的攻击

方法：当nonce k的最高位MSB或一些结构是0，ECC-->hidden number问题（HNP）-->lattice 问题CVP，用Babai求解密钥d。

假设 nonce 的高位已知（biased，假设高位等于0），如果 k 是 ℓ 比特的 nonce，前 δ 个高位是 0（或已知固定值），那么：k = 0...0 (δ bits) || k' (ℓ-δ bits 未知)。此时未知部分k' 是低位小量，满足 k' < 2^{ℓ-δ}。设k的δ比特高位为k0，低位为k'。

根据ECC算法，S=zk^{-1}+Rd mod n，签名=(R,S)，密钥为d，得到Rd=Sk-z mod n。

HNP问题：设p为质数，α∈[1, p-1]是秘密整数，给定m对（t_i, a_i），满足β_i-t_iα+a_i=0 mod p，β_i未知且满足小于B且B<p。即t_iα=β_i-a_i=0 mod p。

那么，签名R即HNP问题中的t_i, d即秘密α，Sk即小量β_i（k高位为0，因此kS=k'S还是很小，且未知，符合HNP中的β_i定义要求），消息的哈希z是a_i。那么对于m对消息和签名，有m个HNP方程。

格构造，构造 (m+1)×(m+1)的格基矩阵 B。

B = [ p I_{m×m}     0_{m×1}]  
       [ t_{1×m}     1/p]

HNP中的β_i-t_iα+a_i=0  mod p 可改写为：β_i+a_i=t_iα +k_i p。这里的β_i是很小量，

设线性组合 t = (k_1,…,k_m, α)，乘上矩阵 B 后得到格向量 x4 =tB= (k_1 p+t_1 α,...k_m p+t_m α, α/p) = (β_1+a_1, ..., β_m+a_m, α/p) ，那么x4=tB与上面的HNP问题等价。

这里，tB-(a1, ..., am, 0)=(β_1, ..., β_m, α/p) ，(β_1, ..., β_m, α/p)的二范数小于√（m+1）B，即可转换为CVP问题的形式：||Bx-t||≤γμ，找到离(a1, ..., am, 0)最近的格点tB= (k_1 p+t_1 α,...k_m p+t_m α, α/p) ，然后取出最后一个坐标α/p，乘以p，即可得到密钥α。

#### 关于算法

LLL：核心是size-reduction 与 Lovász 条件迭代，扩展2维的高斯算法到了n维。

CVP求解：Babai最近平面算法。

最后，其它的密码分析可以看：A Gentle Tutorial for Lattice-Based Cryptanalysis。
