Author：MT
https://github.com/mountaintower/learningzkp

p1 格密码概述
格是后量子零知识区块链的方向

p2 目录
格密码的五个优势：数学语言通用，有理论计算科学基础，密码分析利器，后量子安全，性能强

p5 格的3个数学定义，各有所用
1）n维实数域上的离散加法子群；
2）线性无关的基向量B的整数线性组合的集合；
3）整数矩阵的列空间

p6-10 核心的困难问题
SVP：最短向量问题
SVPγ：找到长度小于γλ1的最短非零格向量（近似），λ1为格上两点最短距离，γ是放松倍数
SIVPγ：找到一组长度小于γλ1~γλn的最短独立向量
CVPγ：找到离指定的t点长度小于γμ的向量，μ是离原点最近的向量长度
CVP变体：离t点的距离最大为d。BDD（有界距离解码）：最多一个解，d小于λ1/2；ADD：至少一个解，d>=μ
LWE：带错学习。As+e=t

p12 CVP可用于解码：m=CVP(B,t)

p13 q元格具有周期性，SIS格可以看做满足线性方程组的点集

p14 LWE可以被看作q-ary格中的CVP。LWE可以看做SIVP的平均版本（LWE的噪声 e 可以被视为SIVP中的“扰动”）。因此，LWE与CVP的近似BDD等价

p15 MSIS即模SIS（最短整数Solution）问题，对随机A，求满足Az模q为0，且范数小于β的z，z是多项式环Rq上的向量

p16 SIS格上的SVP
β越大，SIS满足线性方程组概率越高/向量x范围越大，难度越小；β越大，LWE中的s到t的误差e的范围越大，越难恢复出s

p17 SIS应用：hash算法Ajtai。把m维z向量通过SIS格映射成n维点

p18 NTRU加解密算法：多项式环上的SVP和CVP问题
密钥生成：h=2g/s，s和g都是短多项式。基于SVP，已知h无法推出短向量s
加密：c=rh+m mod q，r是随机多项式
解密：a=cs=rhs+ms=r2g+ms， m=a mod 2。基于CVP，已知c无法求出最接近的a

p21
Kyber基于Ring-LWE，公钥加密
Dilithium基于module格上的LWE，签名
FALCON基于NTRU格结构，签名

p27
从线性代数，概率论，抽象代数开始，连接量子计算、机器学习、计算复杂性、密码学、零知识证明、区块链、信息论、编码理论、伽罗瓦理论、群论、模论、代数数论和代数几何等领域的“大统一”
为代数密码学加入了几何结构，连接离散和连续数学

p28
向量张成空间，格是n维实数离散子群，理想对标代数数论（取模），模数是在环而不是向量空间的域上的一般化
1）环和域的区别
环（Ring）：环是一个代数结构，它包含一个集合和两个二元运算：加法和乘法。环中的元素可以进行加法、减法和乘法，但不一定有除法。环中的元素不一定有乘法逆元。
域（Field）：域是一个特殊的环，其中的元素可以进行加法、减法、乘法和除法（除零以外）。域中的每个非零元素都有一个乘法逆元。
2）模和向量空间的区别
模（Module）：模是定义在环上的，其标量乘法来自一个环。模中的元素可以进行加法、减法和标量乘法，其中标量来自一个环。
向量空间（Vector Space）：向量空间是定义在域上的，其标量乘法来自一个域。向量空间中的元素可以进行加法、减法和标量乘法，其中标量来自一个域。
3）理想与环的关系
理想是环的子集：理想 I 是环 R 的一个子集，但它不仅仅是任意的子集，而是具有特定的代数性质。
理想在环的运算下封闭：理想在加法和乘法运算下是封闭的，特别是它吸收环中的任何元素的乘法。
理想用于构造商环：理想的一个重要应用是构造商环。给定一个环 R 和一个理想 I，可以定义商环 R/I，它是 R 中所有模 I 的等价类的集合。商环在代数数论和代数几何中非常重要。

p29
类域理论（Class Field Theory）
类域理论是研究数域 K 的阿贝尔扩张的理论。它提供了数域的阿贝尔扩张与数域的某些代数结构（如理想类群）之间的对应关系。

p30
数域 K 的基本性质，包括其表示、同构、几何结构和判别式。这些概念在数论中非常重要，特别是在研究数域的算术性质和代数结构时
如果 L 是 K 的代数扩张，那么 L 中的每个元素都是 K 上的代数。换句话说，L 中的元素可以表示为 K 中系数的多项式的根。代数扩张的次数，记作 [L:K]，是指 L 作为 K 上的向量空间的维数。
代数扩张的例子
有理数域的扩张：考虑有理数域 Q 和数域 Q( 更号2），后者是 Q 的代数扩张，因为  
更号2是 Q[x] 中多项式 x^2 −2 的根，而 Q( 更号2) 包含了所有形如 a+b 更号2 的数，其中 a,b∈Q。

p32 格和复杂性理论，ppp：多项式，鸽笼原理

p33
最坏情况到平均情况的归约在密码学中是“圣杯”（Holy Grail），意味着破解难度在所有情况下都是一致的

p34
即使多项式因子的近似SVP也展示了指数级难度

p35
计算复杂性理论定义的六个世界：多项式世界，启发式世界（P不等于NP，但平均情况下不难），悲观世界（平均情况下难但不存在单向函数可以利用），最小密码世界（有单向函数，没有公钥密码学），密码世界（有公钥密码），混淆世界（不可区分，格）
Witness Encryption（见证加密）是一种密码学原语，它允许将消息加密到某个声明，只有拥有证明该声明为真的“证据”的人才能解密该消息。这种加密方法在密码学中具有独特的应用场景，例如在零知识证明、隐私保护和安全通信中。
Indistinguishability Obfuscation（不可区分混淆）：这是一种密码学原语，它确保即使攻击者拥有无限计算能力，也无法区分两个功能等价的程序。

p37
iO + minimal hardness：指的是Obfustopia框架依赖于不可区分混淆的零知识证明（Indistinguishability Obfuscation，简称iO）加上最小难度假设。
NP ⊊ iOBPP：表明Obfustopia的难度基础是NP问题，而不是iOBPP问题。iOBPP是一类计算问题，通常认为比NP问题更难
iOBPP（Interactive Oracle Proof of Proximity）是一种交互式证明系统，它涉及一对随机化算法，即证明者（prover）和验证者（verifier），它们共同接收一个码族C中的码C的规范，该码被视为从有限集S到字母表Σ的函数集合。证明者以显式输入的形式接收相同的函数。iOBPP的交互轮数用r表示，查询复杂度用q表示。
iOBPP的定义如下：一个r轮的iOBPP S=(P,V)是一个(r+1)轮的IOP。如果满足以下条件，我们称S是针对纠错码C={f:S→Σ}的r轮iOBPP，其可靠性（soundness）为s:(0,1]→[0,1]，并且与距离度量△相关

p38
LDN + PRG in NC° + Pairing：这指的是在计算复杂性理论中，线性探测数问题（LDN）和伪随机生成器（PRG）被认为属于NC°类问题。NC°是一类计算问题，这些问题可以在并行计算模型中高效解决。Pairing可能指的是配对（Pairing）问题，它在密码学中用于构造特定类型的密码协议。
Lattice assumptions LWE-with-hints：这指的是基于格的假设和带有提示的学习带误差问题（LWE with hints）。这些假设和问题在密码学中用于构造安全协议，特别是那些旨在抵抗量子计算机攻击的协议。
线性探测数问题（Linear Discriminant Problem，简称 LDN）是密码学中的一个重要概念，它涉及到格理论中的格基向量。在密码学中，格基向量是一组线性无关的向量，它们可以生成整个格。线性探测数问题通常与格的基向量的选择和格的判别式相关联

p43
LLL算法是密码学和数论中的一个里程碑，它不仅提高了格约简的效率，还影响了密码体系的设计和分析。它的出现使得许多之前被认为安全的密码体系变得不再安全，同时也为基于格的密码体系的构造提供了理论基础。尽管有新的算法如BKZ和Sieving算法等，但它们在复杂度上仍然是指数级的，这表明LLL算法在格约简领域中的基础性地位

p45
"Truncated LCG"（截断的线性同余生成器）是一种改进的线性同余生成器（Linear Congruential Generator，LCG）的版本，旨在提高其安全性。LCG是一种伪随机数生成器，它基于线性递归关系产生伪随机数序列。然而，如果LCG的参数（乘数a、增量b和模数m）是已知的，那么即使种子值保密，LCG也是可预测的。为了解决这个问题，截断的LCG只输出每个生成数的部分位（例如，只取最低有效位），从而使得预测变得更加困难。
在密码学中，这种截断技术被用来提高LCG的安全性。例如，如果一个密码算法使用LCG生成随机数，并且这些随机数的某些位是公开的，那么截断的LCG可以防止攻击者通过已知的输出位来预测整个序列。尽管如此，研究表明，即使使用了截断技术，LCG仍然可能存在可预测性的问题，因此，它们通常不推荐用于密码学安全应用。

p48
OWSG（Optimal Witness Size Generator）是一种密码学原语，它与零知识证明（Zero-Knowledge Proofs）相关。在零知识证明中，证明者需要证明他们知道一个特定的值（例如一个密码的私钥），而不需要透露这个值本身。OWSG是一种生成器，它能够生成具有最优大小的证明，使得证明既紧凑又安全。这种生成器在密码学协议设计中非常有用，特别是在需要证明某个陈述的真实性而不泄露任何额外信息的场景中。

p56
LatticeFold 是一种基于格的折叠协议（folding protocol），由 Dan Boneh 和 Binyi Chen 构建，旨在提供后量子安全性并且可以在小域（例如64位）中操作。LatticeFold+ 是对 LatticeFold 的改进，它在多个方面进行了优化：证明者（prover）更快，验证电路更简单，并且生成的证明更短。LatticeFold+ 通过开发两种新的格技术实现了这些改进。首先，它开发了一种新的纯代数范围证明，这种证明比 LatticeFold 中的效率更高，可能具有独立的兴趣。其次，它展示了如何使用基于和检查（sumcheck-based transformation）的新方法来折叠关于双重承诺（double commitments）的语句。
LatticeFold+ 的主要贡献是提供了一个更高效的格基折叠技术，用于简洁的证明系统。该技术通过使用代数范围证明和双重承诺来缩小证明大小。此外，LatticeFold+ 还展示了如何折叠关于双重承诺的语句，这在构建高效简洁证明系统中非常有用。
LatticeFold 协议利用了基于格的承诺，这可能为后量子安全，并且可以与小域一起工作。然而，LatticeFold 有时需要证明者对所有输入见证提供范围证明，使用比特分解（bit-decomposition），这会减慢证明过程。LatticeFold+ 通过开发新的代数范围证明和双重承诺的折叠技术，解决了这个问题。
LatticeFold+ 协议在效率方面与 Hypernova 相当，同时提供了后量子安全性。LatticeFold 特别适用于使用高阶多项式操作的计算，并且可能成为使用高阶多项式的最高效的折叠系统。LatticeFold 可以作为后量子安全性导致性能提升的一个例子。此外，LatticeFold 可能适用于需要在可验证计算场景中不要求零知识的场合。
总的来说，LatticeFold 和 LatticeFold+ 是构建高效简洁证明系统的重要技术，它们通过利用格基承诺和新的折叠技术，提供了后量子安全性和更短的证明。这些技术对于构建后量子时代的密码系统非常有用

p57
向量化（Vectorization）
向量化是一种编程技术，它允许单个指令同时操作多个数据点。这种技术通常用于利用现代处理器中的向量处理单元（Vector Processing Units，简称VPU）来提高性能。在密码学和其他计算密集型应用中，向量化可以帮助加速执行重复性的操作，如加密、解密、散列和聚集等。
SIMD操作
SIMD操作是一种并行处理技术，它允许单个CPU指令同时对多个数据执行操作。这种技术广泛应用于现代处理器架构中，以提高对多媒体、科学计算和密码学等应用的处理效率。SIMD指令集通常包括加载、存储、算术和逻辑操作，它们可以同时处理多个数据向量。

p58 格密码应用未来
信号协议（Signal Protocol）：
PQXDH 是一种基于格的密钥交换协议，它利用 Kyber 公钥加密算法来实现设备间安全通信。这种协议可以在移动设备上实现，如手机和笔记本电脑。
Cloudflare：
指的是在云计算环境中广泛部署机器学习密钥封装（Machine Learning Key Encapsulation，简称ML-KEM）技术。ML-KEM 是一种技术，它允许在加密数据上执行机器学习操作而不泄露数据内容。
Algorand：
FALCON 是一种基于格的数字签名算法，它被用于状态证明系统（State Proof system）。状态证明系统是一种密码学协议，允许用户在不泄露任何敏感信息的情况下证明他们拥有某些信息或状态。

p62
ZKP相关：LaBRADOR and Greyhound
1）SLAP框架（SLAP Framework）
Eurocrypt 2024：这是在2024年欧洲密码学会议（Eurocrypt）上提出的一个框架。
首个基于格的多项式承诺：该框架提出了第一个基于格的多项式承诺方案，该方案具有多项式对数证明大小（polylogarithmic proof size）和验证者时间（verifier time）都在标准模块化SIS（Module-SIS）假设下。
具体的证明大小：对于220个约束条件，具体的证明大小为17MB，比之前的基于格的SNARK（Succinct Non-interactive ARgumentation of Knowledge）系统小了15倍。
2）LaBRADOR和Greyhound（LaBRADOR and Greyhound）
Crypto 2023-24：这是在2023-2024年的密码学会议（Crypto）上提出的两个系统。
LaBRADOR：这是第一个基于格的递归摊销R1CS（Recursively Amortized 1-Constraint Satisfaction）证明系统，实现了O(log n)的证明大小（对于2^20个约束条件，证明大小为58KB）。
Greyhound：这是第一个具体有效的基于格的多项式承诺；对于2^30度的多项式，具有53KB的证明大小，并且有一个3轮评估协议。

p63
LatticeFold 和 LatticeFold+（2024–2025）
LatticeFold：
这是首个针对64位域上的环学习同余（Ring Learning with Errors，简称R1CS）和带错代码学习（Code Learning with Errors，简称CCS）问题的后量子折叠（folding）方案。
该方案的性能与之前的基于配对问题（Pairing-Based Problems，简称PCP）的系统相当。
LatticeFold+：
这是LatticeFold的改进版本，它引入了代数范围证明（algebraic range proofs）和双重承诺技术（double-commitment techniques）。
这些技术使得证明过程快了5倍，并且生成的证明更短。
Neo（Eurocrypt 2025）
Neo：
这是一个基于格的折叠方案，用于CCS问题，它在小素数域上使用“按位付费”（pay-per-bit）的Ajtai承诺。
该方案提供了具体的后量子安全性，意味着它能够抵抗量子计算机的攻击。

这些进展展示了基于格的密码学方案在提供后量子安全性方面的潜力。LatticeFold和LatticeFold+通过改进证明技术和折叠技术，提高了方案的效率和实用性。Neo方案则展示了在小素数域上实现后量子安全性的可能性。这些成果对于设计能够抵御量子计算机攻击的密码系统具有重要意义，因为量子计算机能够破解许多现有的加密算法，包括RSA和ECC。因此，研究和开发后量子密码学方案是密码学领域的一个重要方向

PCP（Pairing-Based Cryptography）是一种基于配对（pairing）问题的密码学方法。这里的“配对”问题指的是在特定的数学结构中找到两个元素的配对，使得它们满足某种特定的数学关系。在密码学中，这些配对问题通常是困难的，即不存在有效的算法能够在多项式时间内解决它们
CCS（Code-based Cryptography Schemes，基于编码的密码学方案）是一种基于编码理论的密码学方法。这类密码学方案利用编码理论中的困难问题来构建公钥密码体系，特别是用于公钥加密和数字签名。
基于编码的密码学方案利用编码理论中的困难问题，如解码问题（Decoding Problem）或最小距离问题（Minimum Distance Problem），来设计密码算法。这些问题在编码理论中是众所周知的难题，它们的计算复杂性为基于编码的密码学方案提供了安全性基础。
前量子时代是pederson承诺

p64 经典和基于格的多项式承诺
格比FRI还小2倍

其它
结构化格（Structured Lattices）是格理论中的一个概念，它指的是那些具有额外结构或规则排列的格。在密码学中，结构化格通常指的是那些可以更容易进行数学操作和分析的格，这些操作和分析对于密码学协议的设计和安全性评估至关重要。

结构化格可以有许多不同的形式，例如：

1. 循环格（Cyclic Lattices）：这些格由单个基向量通过整数倍数生成，并且具有高度对称的结构。

2. 理想格（Ideal Lattices）：在数域上的格可以被视为理想，这些格与代数环的结构紧密相关联。

3. 模块格（Module Lattices）：这些格是更一般的结构，它们允许更复杂的构造，并且可以包含理想格和循环格作为特殊情况。

结构化格在密码学中的应用包括：

- 提高效率：结构化格可以使得某些密码学操作更高效，例如加密、解密和签名生成。
- 安全性分析：通过研究结构化格的性质，可以更好地理解和评估密码学方案的安全性。
- 量子抗性：结构化格理论在设计能够抵抗量子计算机攻击的密码学方案中起着核心作用，因为它们基于的数学问题（如最短独立向量问题）被认为即使在量子计算机上也是难以解决的。

在密码学文献中，结构化格通常与特定的密码学原语和协议相关联，例如基于格的公钥加密（PKE）和数字签名方案。这些方案利用结构化格的数学性质来提供强大的安全保证，同时保持实际应用中的效率和可行性。

NIST实现格算法基本使用C，区块链基本用Rust
其它参考文章
16年的Latiice十年综述